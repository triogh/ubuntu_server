Ansible Documentation
***

Title: how-to-install-and-configure-ansible-on-an-ubuntu-12-04-vps
===
Source: https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-ansible-on-an-ubuntu-12-04-vps

Added: Thu Dec  1 16:47:12 CET 2016
Created: PostedFebruary 6, 2014 


Introduction
+++

Configuration management systems are designed to make controlling large numbers of servers easy for administrators and operations teams. They allow you to control many different systems in an automated way from one central location.

While there are many popular configuration management systems available for Linux systems, such as Chef and Puppet, these are often more complex than many people want or need. Ansible is a great alternative to these options because it has a much smaller overhead to get started.

In this guide, we will discuss how to install Ansible on an Ubuntu 12.04 machine and go over some basics of how to use the software.


How Does Ansible Work?
+++

Ansible works by configuring client machines from an computer with Ansible components installed and configured.

It communicates over normal SSH channels in order to retrieve information from remote machines, issue commands, and copy files. Because of this, an Ansible system does not require any additional software to be installed on the client computers.

This is one way that Ansible simplifies the administration of servers. Any server that has an SSH port exposed can be brought under Ansible's configuration umbrella, regardless of what stage it is at in its life cycle.

Any computer that you can administer through SSH, you can also administer through Ansible.

Ansible takes on a modular approach, making it easy to extend to use the functionalities of the main system to deal with specific scenarios. Modules can be written in any language and communicate in standard JSON.

Configuration files are mainly written in the YAML data serialization format due to its expressive nature and its similarity to popular markup languages. Ansible can interact with clients through either command line tools or through its configuration scripts called Playbooks.


Install Ansible on an Ubuntu 12.04 VPS
+++

To begin exploring Ansible as a means of managing our various servers, we need to install the Ansible software on at least one machine. 

MY_NOTE:
Ansible is now available in the default Ubuntu repositories, so there is no need for additional third party repos.


        #
        sudo apt-get update
        sudo apt-get install ansible


Set Up SSH Keys
+++

As we mentioned above, Ansible primarily communicates with client computers through SSH. While it certainly has the ability to handle password-based SSH authentication, SSH keys help keep things simple.

We can set up SSH keys in two different ways depending on whether you already have a key you want to use. We will assume that the servers you want to be administering will be DigitalOcean droplets.


Create a New SSH Key Pair
---

If you do not already have an SSH key pair that you would like to use for Ansible administration, we can create one now on your Ansible VPS.

We will create an SSH key pair on our Ansible droplet to authenticate with the hosts that it will administer.

As the user you will be controlling Ansible with, create an RSA key-pair by typing:

ssh-keygen
~~~

        #
        ssh-keygen


You will be asked to specify the file location of the created key pair, a passphrase, and the passphrase confirmation. Press ENTER through all of these to accept the default values.

Your new keys are available in your user's ~/.ssh directory. The public key (the one you can share) is called id_rsa.pub. The private key (the one that you keep secure) is called id_rsa.


You can add them to your DigitalOcean control panel to allow you to embed your SSH key into newly created droplets. This will allow your Ansible droplet to SSH into your new droplets immediately, without any other authentication.

To do this, click on the "SSH Keys" link on the left-hand navigation menu. In the new screen, click on the "Add SSH Key" button in the top-right corner:


Enter the name you want associated with this key into the top field. On your Ansible VPS instance, type this to get the contents of your public key:


        #
        cat ~/.ssh/id_rsa.pub
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzmGgsqjSFuOBbjZB1sgquKpp3Ty+FgqoLrzjKbbk9VGOH6kM37aAhyxxmTQfe69lhYi/WCai+mrXOyY9IiQbUfZ4jsfPE9DS3zHhmnGiBWA7pedCTJ/Nhf06dmhAJIbExW3uDghbPbzbSA5Ihn1x0F5FXtSMDoFtyjcwUwJxc2z/kk9TKcFSl8qqf4IYBYE7c+EKaYRBjjDP4AQmiwjTPuipsmub7C0OGF0dTMatIa0lok6rwy91nmhCQV6polG0+Fsk4YrY8Yh5xz6wE0lOvc8BwP9nL0zsnw6Ey0MHV9BbMqtyD6x/fCurpIkMHJK4nv79rToSWA0AwoP/bJXh7 demo@ansible0


The string that is given back to you is what you need to paste in the second field in the DigitalOcean control panel:


Click "Create SSH Key" to add your key to the control panel. Now, whenever you create a new droplet, you will be able to embed your public SSH key into the new server, allowing you to communicate with your Ansible instance. You just need to select the key in the "Add optional SSH Keys" section of the droplet creation process:


Transfer an Existing SSH Key Pair to Ansible
---

If you already have a SSH key pair that you are using to authenticate with your droplets, you can transfer the credentials to your new Ansible droplet instead of creating a new pair. This has the advantage of making it automatically work with any servers you have already configured to use the key.

On the computer where you have configured SSH key authentication for your droplets, get the public key by typing:


        #
        cat ~/.ssh/id_rsa.pub
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzmGgsqjSFuOBbjZB1sgquKpp3Ty+FgqoLrzjKbbk9VGOH6kM37aAhyxxmTQfe69lhYi/WCai+mrXOyY9IiQbUfZ4jsfPE9DS3zHhmnGiBWA7pedCTJ/Nhf06dmhAJIbExW3uDghbPbzbSA5Ihn1x0F5FXtSMDoFtyjcwUwJxc2z/kk9TKcFSl8qqf4IYBYE7c+EKaYRBjjDP4AQmiwjTPuipsmub7C0OGF0dTMatIa0lok6rwy91nmhCQV6polG0+Fsk4YrY8Yh5xz6wE0lOvc8BwP9nL0zsnw6Ey0MHV9BbMqtyD6x/fCurpIkMHJK4nv79rToSWA0AwoP/bJXh7 demo@ansible0


On your Ansible server, you need to create a hidden directory to store your keys. Call it .ssh so that the SSH program knows where to find it:


        #
        mkdir ~/.ssh


We should lock access to this directory down so that only you can enter or write to it:


        #
        chmod 700 ~/.ssh


Now, move into the directory and open a file called id_rsa.pub in your text editor:


        #
        cd ~/.ssh
        nano id_rsa.pub


Paste the output of your public key from your home computer into this file:


        #
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzmGgsqjSFuOBbjZB1sgquKpp3Ty+FgqoLrzjKbbk9VGOH6kM37aAhyxxmTQfe69lhYi/WCai+mrXOyY9IiQbUfZ4jsfPE9DS3zHhmnGiBWA7pedCTJ/Nhf06dmhAJIbExW3uDghbPbzbSA5Ihn1x0F5FXtSMDoFtyjcwUwJxc2z/kk9TKcFSl8qqf4IYBYE7c+EKaYRBjjDP4AQmiwjTPuipsmub7C0OGF0dTMatIa0lok6rwy91nmhCQV6polG0+Fsk4YrY8Yh5xz6wE0lOvc8BwP9nL0zsnw6Ey0MHV9BbMqtyD6x/fCurpIkMHJK4nv79rToSWA0AwoP/bJXh7 demo@ansible0



Save and close the file. We will make sure that this file has the correct permissions by typing:


        #
        chmod 644 id_rsa.pub


Now, back on your local computer that is configured for SSH key access, type:


        #
        cat ~/.ssh/id_rsa
        -----BEGIN RSA PRIVATE KEY-----
        MIIEpgIBAAKCAQEA85hoLKo0hbjgW42QdbIKriqad08vhYKqC684ym25PVRjh+pD
        N+2gIcl8Zk0H3uvZYWIv1gmsfpq1zsmPSIkG1H2eI7HzxPQ0qMx4ZpxogVgO6XnQ
        kyfzYX9OnZoQCSGxMVt7g4IWz2820gOSIZ9cdBeRV7UjA6Bbco3MFMCcXNs/5JPU
        ynBUpfKqn+CGAWBO3PhCmmEQY4wz+AEJosI0z7oqbJrm/AtDhhdHUzGrSGtJaJOq
        . . .
        . . .
        cqsqOEzXAoGBAPMJJ8RrKUBuSjVNkzebst9sBgNadmaoQUoMHUDr8KpCZhWAoHB7
        1VKmq7VSphQSruI31qy2M88Uue1knC/nQr1bE1DITZgezETSsDqsAMBo8bqDN6TT
        qVJgG+TS9BRC+IowuzMVV5mzrfJjkrb+GG+xWSXrTLZMbeeTf+D0SfVo
        -----END RSA PRIVATE KEY-----


The output will be quite long.

Back on your Ansible droplet, we need to create a new file in the ~/.ssh directory:


        #
        nano id_rsa


Inside, paste the results of the previous command on your local computer:


        #
        -----BEGIN RSA PRIVATE KEY-----
        MIIEpgIBAAKCAQEA85hoLKo0hbjgW42QdbIKriqad08vhYKqC684ym25PVRjh+pD
        N+2gIcl8Zk0H3uvZYWIv1gmsfpq1zsmPSIkG1H2eI7HzxPQ0qMx4ZpxogVgO6XnQ
        kyfzYX9OnZoQCSGxMVt7g4IWz2820gOSIZ9cdBeRV7UjA6Bbco3MFMCcXNs/5JPU
        ynBUpfKqn+CGAWBO3PhCmmEQY4wz+AEJosI0z7oqbJrm/AtDhhdHUzGrSGtJaJOq
        . . .
        . . .
        cqsqOEzXAoGBAPMJJ8RrKUBuSjVNkzebst9sBgNadmaoQUoMHUDr8KpCZhWAoHB7
        1VKmq7VSphQSruI31qy2M88Uue1knC/nQr1bE1DITZgezETSsDqsAMBo8bqDN6TT
        qVJgG+TS9BRC+IowuzMVV5mzrfJjkrb+GG+xWSXrTLZMbeeTf+D0SfVo
        -----END RSA PRIVATE KEY-----


Make sure that you include the first and last marker lines. They are required in order for the key file to be valid. Save and close the file.

We need to change the permissions to keep this file secure:


        #
        chmod 600 id_rsa


At this point, Ansible will be able to use these SSH keys to communicate with any servers that have the key embedded.


MY_NOTE:
When testing with a Vagrant box, I just copied the ssh public key from the host machine to the ".ssh/authorized_keys" file in the Vagrant box, and restarted the ssh daemon. Then I can connect with the command below.


        #
        $ ssh vagrant@127.0.0.1 -p2222


Configuring Ansible Hosts
+++

Ansible keeps track of all of the servers that it knows about through a "hosts" file. We need to set up this file first before we can begin to communicate with our other computers.

Open the file with root privileges like this:


        #
        sudo nano /etc/ansible/hosts


You will see a file that has a lot of example configurations, none of which will actually work for us since these hosts are made up. So to start, let's comment out all of the lines in this file by adding a "#" before each line.

We will keep these examples in the file to help us with configuration if we want to implement more complex scenarios in the future.

Once all of the lines are commented out, we can begin adding our actual hosts.

The hosts file is fairly flexible and can be configured in a few different ways. The syntax we are going to use though looks something like this:


        #
        [group_name]
        alias ansible_ssh_host=server_ip_address


The group_name is an organizational tag that lets you refer to any servers listed under it with one word. The alias is just a name to refer to that server.

So in our scenario, we are imagining that we have three servers we are going to control with Ansible. These servers are accessible from the Ansible droplet by typing:


        #
        ssh root@server_ip_address


You should not be prompted for a password if you have set this up correctly. We will assume that our droplets' IP addresses are 192.0.2.1, 192.0.2.2, and 192.0.2.3. We will set this up so that we can refer to these individually as host1, host2, and host3, or as a group as droplets.

This is the block that we should add to our hosts file to accomplish this:


        #
        [droplets]
        host1 ansible_ssh_host=192.0.2.1
        host2 ansible_ssh_host=192.0.2.2
        host3 ansible_ssh_host=192.0.2.3



MY_NOTE:
This is what I did on my test host machine, so that I could reach the Vagrant box I created previously, and where I copied the public ssh key, into the authorized_keys file on the Vagrant box.


        #
        [test_group]
        test_machine ansible_host=127.0.0.1 ansible_port=2222 ansible_user=vagrant


Relevant Ansible docs for the inventory file.
http://docs.ansible.com/ansible/intro_inventory.html


        #
        $ ansible all -m ping
        test_machine | SUCCESS => {
            "changed": false, 
            "ping": "pong"
        }



Hosts can be in multiple groups and groups can configure parameters for all of their members. Let's try this out now.

With our current settings, if we tried to connect to any of these hosts with Ansible, the command would fail (assuming you are not operating as the root user). This is because your SSH key is embedded for the root user on the remote systems and Ansible will by default try to connect as your current user. A connection attempt will get this error:


        #
        host1 | FAILED => SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue


In my Ansible computer, I'm using a user called demo. Ansible will try to connect to each host with ssh demo@server. This will not work if the demo user is not on the remote system.

We can create a file that tells all of the servers in the "droplets" group to connect using the root user.

To do this, we will create a directory in the Ansible configuration structure called group_vars. Within this folder, we can create YAML-formatted files for each group we want to configure:

/etc/ansible/group_vars
---

/etc/ansible/group_vars/droplet
---

        #
        sudo mkdir /etc/ansible/group_vars
        sudo nano /etc/ansible/group_vars/droplets

We can put our configuration in here. YAML files start with "---", so make sure you don't forget that part.


ansible_ssh_user: root
---

        #
		#
        ---
        ansible_ssh_user: root



Save and close this file when you are finished.

If you want to specify configuration details for every server, regardless of group association, you can put those details in a file at: 


/etc/ansible/group_vars/all
---

        #
        /etc/ansible/group_vars/all 


Individual hosts can be configured by creating files under a directory at 

/etc/ansible/host_vars
---

        #
        /etc/ansible/host_vars


Using Simple Ansible Commands
+++

Now that we have our hosts set up and enough configuration details to allow us to successfully connect to our hosts, we can try out our very first command.

Ping all of the servers you configured by typing:


$ ansible -m ping all
---


        #
		host1 | success >> {
			"changed": false,
			"ping": "pong"
		}

		host3 | success >> {
			"changed": false,
			"ping": "pong"
		}

		host2 | success >> {
			"changed": false,
			"ping": "pong"
		}


This is a basic test to make sure that Ansible has a connection to all of its hosts.

The "all" means all hosts. We could just as easily specify a group:

$ ansible -m ping droplets
---


We could also specify an individual host:

$ ansible -m ping host1
---


We can specify multiple hosts by separating them with colons:

$ ansible -m ping host1:host2
---


The -m ping portion of the command is an instruction to Ansible to use the "ping" module. These are basically commands that you can run on your remote hosts. The ping module operates in many ways like the normal ping utility in Linux, but instead it checks for Ansible connectivity.

The ping module doesn't really take any arguments, but we can try another command to see how that works. We pass arguments into a script by typing -a.

The "shell" module lets us send a terminal command to the remote host and retrieve the results. For instance, to find out the memory usage on our host1 machine, we could use:


$ ansible -m shell -a 'free -m' host1
---


		#
		host1 | success | rc=0 >>
					 total       used       free     shared    buffers     cached
		Mem:          3954        227       3726          0         14         93
		-/+ buffers/cache:        119       3834
		Swap:            0          0          0



Conclusion

By now, you should have your Ansible server configured to communicate with the servers that you would like to control. We have verified that Ansible can communicate with each host and we have used the ansible command to execute simple tasks remotely.

Although this is useful, we have not covered the most powerful feature of Ansible in this article: Playbooks. We have set up a great foundation for working with our servers through Ansible, but the heavy lifting will be done in a future article, when we cover how to use Playbooks to automate configuration of your remote computers.


Comments
+++

June 1, 2014

In the section "Using Simple Ansible Commands," you say, "We can specify multiple hosts by separating them with colons." More precisely you can do the union, intersection, or difference of the machines or groups listed. The Ansible documents on this are a bit weak, http://docs.ansible.com/intro_patterns.html but I learned it from http://zaiste.net/2014/05/ansible_101/ . Look at the middle of the page for the section named Usage. "Groups can be combined A:B designates the union of groups A and B A:&B designates the intersection of groups A and B A:!B designates the difference, all from A without those in B"


October 25, 2014

Good introductory tutorial! I think it would be interesting to point that connecting and running the tasks as root might not be the best practice on a daily basis, as all commands will be executed as root.





Title: how-to-create-ansible-playbooks-to-automate-system-configuration-on-ubuntu
===
Source: https://www.digitalocean.com/community/tutorials/how-to-create-ansible-playbooks-to-automate-system-configuration-on-ubuntu

Added: Thu Dec  1 19:52:05 CET 2016
Created: PostedFebruary 7, 2014


Introduction
+++

Ansible is an easy configuration management system that can be used to automate and organize your system configuration tasks for a large network of computers. While some other configuration management systems require many different packages to be installed on the server and client systems, with Ansible, you only need to install a server component and have SSH access to the client machines.


In a previous guide, we discussed how to install the Ansible software and learn basic commands. In this guide, we will discuss Ansible playbooks, which are Ansible's way of creating automated scripts to configure client computers.

We will assume that you have a configured Ansible server and a few clients, just as we left off in the last tutorial. In our guide, the server is a Ubuntu 12.04 machine, and the clients that we are going to be configuring are also Ubuntu 12.04 machines, for ease of explanation.



What are Ansible Playbooks?
+++

Ansible playbooks are a way to send commands to remote computers in a scripted way. Instead of using Ansible commands individually to remotely configure computers from the command line, you can configure entire complex environments by passing a script to one or more systems.

Ansible playbooks are written in the YAML data serialization format. If you don't know what a data serialization format is, think of it as a way to translate a programmatic data structure (lists, arrays, dictionaries, etc) into a format that can be easily stored to disk. The file can then be used to recreate the structure at a later point. JSON is another popular data serialization format, but YAML is much easier to read.


Each playbook contains one or more plays, which map hosts to a certain function. Ansible does this through something called tasks, which are basically module calls.


Exploring a Basic Playbook
+++

Let's look at a basic playbook:



		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

		  handlers:
			- name: start nginx
			  service: name=nginx state=started


Let's break this down in sections so we can understand how these files are built and what each piece means.

The file starts with:


		#
		#
		---


This is a requirement for YAML to interpret the file as a proper document. YAML allows multiple "documents" to exist in one file, each separated by ---, but Ansible only wants one per file, so this should only be present at the top of the file.

YAML is very sensitive to white-space, and uses that to group different pieces of information together. You should use only spaces and not tabs and you must use consistent spacing for your file to be read correctly. Items at the same level of indentation are considered sibling elements.


Items that begin with a - are considered list items. Items that have the format of key: value operate as hashes or dictionaries. That's pretty much all there is to basic YAML.


YAML documents basically define a hierarchical tree structure with the containing elements further to the left.

On the second line, we have this:


		#
		#
		---
		- hosts: droplets


This is a list item in YAML as we learned above, but since it is at the left-most level, it is also an Ansible "play". Plays are basically groups of tasks that are performed on a certain set of hosts to allow them to fulfill the function you want to assign to them. Each play must specify a host or group of hosts, as we do here.

Next, we have a set of tasks:


		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx



At the top level, we have "tasks:" at the same level as "hosts:". This contains a list (because it starts with a "-") which contains key-value pairs.

The first one, "name", is more of a description than a name. You can call this whatever you would like.

The next key is "apt". This is a reference to an Ansible module, just like when we use the ansible command and type something like:

$ ansible -m apt -a 'whatever' all
---


This module allows us to specify a package and the state that it should be in, which is "installed" in our case. The update-cache=true part tells our remote machine to update its package cache (apt-get update) prior to installing the software.

The "notify" item contains a list with one item, which is called "start nginx". This is not an internal Ansible command, it is a reference to a handler, which can perform certain functions when it is called from within a task. We will define the "start nginx" handler below.


		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

		  handlers:
			- name: start nginx
			  service: name=nginx state=started


The "handlers" section exists at the same level as the "hosts" and "tasks". Handlers are just like tasks, but they only run when they have been told by a task that changes have occurred on the client system.


For instance, we have a handler here that starts the Nginx service after the package is installed. The handler is not called unless the "Installs nginx web server" task results in changes to the system, meaning that the package had to be installed and wasn't already there.

We can save this playbook into a file called something like "nginx.yml".

Just for some context, if you were to write this same file in JSON, it might look something like this:


		#
		#
		[
			{
				"hosts": "droplets",
				"tasks": [
					{
						"name": "Installs nginx web server",
						"apt": "pkg=nginx state=installed update_cache=true",
						"notify": [
							"start nginx"
						]
					}
				],
				"handlers": [
					{
						"name": "start nginx",
						"service": "name=nginx state=started"
					}
				]
			}
		]



As you can see, YAML is much more compact and most people would say more readable.


MY_NOTE:
Two perl scripts, first just a proof of concept.
Second works on the example playbook given above, and translates it to JSON, but it had problems with tabs, and so i had to remove tabs, and use spaces instead as indentation in YAML.



First script.

		#
		$ cat yaml2json.pl
		#!/usr/bin/env perl
		# Name:
		# Version:

		use strict;
		use warnings;

		use YAML;
		use JSON;

		# Load a YAML hash containing a scalar ref as a value.
		my ($hashref) = Load(<<'END_YAML');
		---
		bar: ref
		foo: 1
		END_YAML

		use Data::Dump;
		dd $hashref;

		my $json_text = encode_json($hashref);


Output:

		#
		$ perl yaml2json.pl
		{ bar => "ref", foo => 1 }


Second script.


		#
		$ cat yaml2json_2.pl
		#!/usr/bin/env perl
		# Name:
		# Version:

		use strict;
		use warnings;

		use YAML;
		use JSON;

		my $slurped;

		{
		local $/ = undef;
		$slurped = <DATA>;
		}

		# Load a YAML hash containing a scalar ref as a value.
		my ($hashref) = Load($slurped);

		use Data::Dump;
		dd $hashref;

		my $json_text = encode_json($hashref);
		__DATA__
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

		  handlers:
			- name: start nginx
			  service: name=nginx state=started




Output:

		
		#
		$ perl yaml2json_2.pl
		[
		  {
			handlers => [
						  { name => "start nginx", service => "name=nginx state=started" },
						],
			hosts    => "droplets",
			tasks    => [
						  {
							apt => "pkg=nginx state=installed update_cache=true",
							name => "Installs nginx web server",
							notify => ["start nginx"],
						  },
						],
		  },
		]


The source of the first script.
http://stackoverflow.com/questions/25633657/perl-yaml-to-json#25633718

Slurp whole YAML into scalar variable, found useful example on page below.
https://perlmaven.com/slurp



Running an Ansible Playbook
+++

Once you have a playbook built, you can call it easily using this format:

$ ansible-playbook playbook.yml
---

For instance, if we wanted to install and start up Nginx on all of our droplets, we could issue this command:

$ ansible-playbook nginx.yml
---

Since the playbook itself specifies the hosts that it should run against (namely, the "droplets" group we created in the last tutorial), we do not have to specify a host to run against.

However, if we would like to filter the host list to only apply to one of those hosts, we can add a flag to specify a subset of the hosts in the file:


$ ansible-playbook -l host_subset playbook.yml
---

$ ansible-playbook -l host3 nginx.yml
---


Adding Features to the Playbook
+++

Right now our playbook looks like this:


		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

		  handlers:
			- name: start nginx
			  service: name=nginx state=started


It is simple and it works, but all it is doing is installing a piece of software and starting it. That's not very beneficial by itself.

We can start to expand the functionality by adding tasks to our playbook.


Add a Default Index File
+++


We can tell it to transfer a file from our Ansible server onto the host by adding some lines like this:

		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

			- name: Upload default index.html for host
			  copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644

		  handlers:
			- name: start nginx
			  service: name=nginx state=started


We can then make a directory called static_files in our current directory and place an index.html file inside.


		#
		mkdir static_files
		nano static_files/index.html


Inside of this file, let's just create a basic html structure:


		#
		<html>
		  <head>
			<title>This is a sample page</title>
		  </head>
		  <body>
			<h1>Here is a heading!</h1>
			<p>Here is a regular paragraph.  Wow!</p>
		  </body>
		</html>



Save and close the file.

Now, when we re-run the playbook, Ansible will check each task. It will see that Nginx is already installed on the host, so it will leave it be. It will see the new task section and replace the default index.html file with the one from our server.


Registering Results
+++

When you are installing and configuring services manually, it is almost always necessary to know whether your actions were successful or not. We can cook this functionality into our playbooks by using "register".

For each task, we can optionally register its result (failure or success) in a variable that we can check later on.

When using this functionality, we also have to tell Ansible to ignore errors for that task, since normally it aborts the playbook execution for that host if any trouble happens.

So, if we want to check whether a task has failed or not to decide on subsequent steps, we can use the register functionality.


For instance, we could tell our playbook to upload an index.php file if it exists. If that task fails, we could instead try to upload an index.html file. We will check for the failure condition in the other task because we only want to upload the HTML file if the PHP file fails:


		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

			- name: Upload default index.php for host
			  copy: src=static_files/index.php dest=/usr/share/nginx/www/ mode=0644
			  register: php
			  ignore_errors: True

			- name: Remove index.html for host
			  command: rm /usr/share/nginx/www/index.html
			  when: php|success

			- name: Upload default index.html for host
			  copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644
			  when: php|failed

		  handlers:
			- name: start nginx
			  service: name=nginx state=started


Note: We have not configured our host to handle PHP files at this time, so even if you did upload a PHP file, it would not be processed correctly.

This new version tries to upload a PHP index file to the host. It registers the success of the operation into a variable called "php".

If this operation was successful, the task to remove the index.html file is run next.

If the operation failed, the index.html file is uploaded instead.


Conclusion

Now, you should have a good handle on how to automate complex tasks using Ansible. This is a basic example of how you can begin to build your configuration library.

Combining host and group definitions as we learned about in the first tutorial, and using available variables to fill in information, we can begin to put together complex computer systems that interact with each other. In a future article, we will discuss how to implement variables into our playbooks and create roles to help manage complex tasks.


Comments
+++

March 17, 2014

According to the ansible docs(http://docs.ansible.com/apt_module.html) the command equivalent to apt-get update is actually update_cache=yes rather than update_cache=true Otherwise, I like the tutorial.




Title: how-to-use-ansible-roles-to-abstract-your-infrastructure-environment
===
Source: https://www.digitalocean.com/community/tutorials/how-to-use-ansible-roles-to-abstract-your-infrastructure-environment

Added: Fri Dec  2 16:00:35 CET 2016
Created: PostedFebruary 11, 2014


Introduction
+++

Ansible is an easy to use configuration management system that can assist you in configuring large numbers of servers from a single machine. You can automate complex tasks and easily add machines to your infrastructure without too much trouble.

In previous articles, we discussed how to install and configure Ansible and how to create playbooks to automate system configuration. In this guide, we will discuss how to use Ansible roles to allow you to break up configuration into more modular steps.


We will assume that you have Ansible installed on one Ubuntu 12.04 VPS as we demonstrated in the previous guides. You will also need one or more other computers configured as hosts within the Ansible configuration.


What is an Ansible Role?
+++


You've been exposed to how Ansible can interact with configured clients from the command line with the ansible command, and how you can automate configuration with playbooks run through the ansible-playbook command. Where do roles fit into this scheme?

Simply put, roles are a further level of abstraction that can be useful for organizing playbooks. As you add more and more functionality and flexibility to your playbooks, they can become unwieldy and difficult to maintain as a single file. Roles allow you to create very minimal playbooks that then look to a directory structure to determine the actual configuration steps they need to perform.

Organizing things into roles also allows you to reuse common configuration steps between different types of servers. This is already possible by "including" other files within a playbook, but with roles, these types of links between files are automatic based on a specific directory hierarchy.

In general, the idea behind roles is to allow you to define what a server is supposed to do, instead of having to specify the exact steps needed to get a server to act a certain way.


Creating Role Framework
+++

In order for Ansible to correctly handle roles, we need to build a directory structure that it can find and understand. We can do this by creating a "roles" directory in our working directory for Ansible.

We're assuming here that you've been using your user's home directory as the Ansible working directory. You should change to whatever actual directory you are keeping your Ansible configuration in.

We are going to create a directory called "roles" where Ansible will look for our roles.

mkdir roles
---

        #
        cd ~
        mkdir roles
        cd roles


Within this directory, we will define our roles. We will basically create a directory for each role that we will create. Since we are going to replicate our Nginx playbook, let's create an Nginx role:

mkdir nginx
---

		#
		mkdir nginx
		cd nginx


Within this directory, we create another set of directories that will help us separate the different sections of a normal playbook. Create these directories now:


mkdir defaults files handlers meta templates tasks vars
---

		#
		mkdir defaults files handlers meta templates tasks vars 


These are the directories that will contain all of the code to implement our configuration. You may not use all of the directories, so in real practice, you may not need to create all of these directories.


This is what they are all for:


    - files: This directory contains regular files that need to be transferred to the hosts you are configuring for this role. This may also include script files to run.
    - handlers: All handlers that were in your playbook previously can now be added into this directory.
    - meta: This directory can contain files that establish role dependencies. You can list roles that must be applied before the current role can work correctly.
    - templates: You can place all files that use variables to substitute information during creation in this directory.
    - tasks: This directory contains all of the tasks that would normally be in a playbook. These can reference files and templates contained in their respective directories without using a path.
    - vars: Variables for the roles can be specified in this directory and used in your configuration files.

Within all of the directories but the "files" and "templates", if a file called main.yml exists, its contents will be automatically added to the playbook that calls the role.


Abstracting a Playbook to a Role
+++

For many playbooks, it would make more sense to implement the functionality as a role. We can turn our Nginx playbook from the last article into a role to organize things better.

We should already have the roles/nginx/{subdirectories} structure set up from the last section. Now, we need to create some main.yml files in our structure.


Creating the Tasks main.yml File
+++

We'll start with the tasks subdirectory. Move to that directory now:


		#
		cd ~/roles/nginx/tasks


Now, we need to copy the nginx.yml file into this directory:


		#
		cp ~/nginx.yml main.yml


Now, we need to edit the main file and remove everything that is not a tasks:


		#
		nano main.yml


The file should look like this when you begin:



		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

			- name: Upload default index.php for host
			  copy: src=static_files/index.php dest=/usr/share/nginx/www/ mode=0644
			  register: php
			  ignore_errors: True

			- name: Remove index.html for host
			  command: rm /usr/share/nginx/www/index.html
			  when: php|success

			- name: Upload default index.html for host
			  copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644
			  when: php|failed

		  handlers:
			- name: start nginx
			  service: name=nginx state=started


We only want to keep the lines that are red. 


		#
		- name: Installs nginx web server
		  apt: pkg=nginx state=installed update_cache=true
		  notify:
			- start nginx

		- name: Upload default index.php for host
		  copy: src=static_files/index.php dest=/usr/share/nginx/www/ mode=0644
		  register: php
		  ignore_errors: True

		- name: Remove index.html for host
		  command: rm /usr/share/nginx/www/index.html
		  when: php|success

		- name: Upload default index.html for host
		  copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644
		  when: php|failed




Furthermore, we can remove the extraneous spaces to the left of our tasks. After our changes, our new tasks/main.yml file will look like this:


		#
		#
		---
		- name: Installs nginx web server
		  apt: pkg=nginx state=installed update_cache=true
		  notify:
			- start nginx

		- name: Upload default index.php for host
		  copy: src=static_files/index.php dest=/usr/share/nginx/www/ mode=0644
		  register: php
		  ignore_errors: True

		- name: Remove index.html for host
		  command: rm /usr/share/nginx/www/index.html
		  when: php|success

		- name: Upload default index.html for host
		  copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644
		  when: php|failed



As you can see, this is a lot easier to read in terms of just recognizing the steps that are to be performed.

One additional change that we should make is how we references external files in our configuration. Our src lines reference a "static_files" directory. This is unnecessary if we place all of our static files in the "files" subdirectory. Ansible will find them automatically.

When we change those lines, our finished tasks/main.yml file looks like this:


		#
		#
		---
		- name: Installs nginx web server
		  apt: pkg=nginx state=installed update_cache=true
		  notify:
			- start nginx

		- name: Upload default index.php for host
		  copy: src=index.php dest=/usr/share/nginx/www/ mode=0644
		  register: php
		  ignore_errors: True

		- name: Remove index.html for host
		  command: rm /usr/share/nginx/www/index.html
		  when: php|success

		- name: Upload default index.html for host
		  copy: src=index.html dest=/usr/share/nginx/www/ mode=0644
		  when: php|failed


Save and close the file when you are finished.


Creating the Handlers main.yml File
+++

Now that we have the bulk of the playbook in the tasks/main.yml file, we need to move the handlers section into a file located at handlers/main.yml.

Copy the nginx.yml file again, this time into the handlers directory:


		#
		cd ~/roles/nginx/handlers
		cp ~/nginx.yml main.yml


Again, open the file in your text editor:


		#
		nano main.yml


The parts that we need to keep are in red again:


		#
		#
		---
		- hosts: droplets
		  tasks:
			- name: Installs nginx web server
			  apt: pkg=nginx state=installed update_cache=true
			  notify:
				- start nginx

			- name: Upload default index.php for host
			  copy: src=static_files/index.php dest=/usr/share/nginx/www/ mode=0644
			  register: php
			  ignore_errors: True

			- name: Remove index.html for host
			  command: rm /usr/share/nginx/www/index.html
			  when: php|success

			- name: Upload default index.html for host
			  copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644
			  when: php|failed

		  handlers:
			- name: start nginx
			  service: name=nginx state=started



Remove the whitespace from before the handlers also. In the end, the file should look like this:


		#
		#
		---
		- name: start nginx
		  service: name=nginx state=started


Save and close the file when you are finished.


Finishing Up
+++

Since our original playbook was very simple, we're almost done.

First, we need to move the index.html page (and the index.php page if you created one) out of the ~/static_files directory and put them into the ~/roles/nginx/files directory:


		#
		cp ~/static_files/* ~/roles/nginx/files


If our role depended on another role, we could add a file in the meta directory called main.yml. This file might specify that this role depends on a role called "apt".

If our role depended on a role called "apt", the file at ~/roles/nginx/meta/main.yml might look like this:


		#
		#
		---
		dependencies:
		  - { role: apt }


This would take the "apt" role and place the information from that role before our Nginx information so that our role has its proper dependencies prior to starting.

We said earlier that there is a "vars" directory that can be used to set variables for our role. While it is possible to configure default parameters for a role through a vars/main.yml file, this is usually not recommended, because it makes the details of your configuration reside within the roles hierarchy.


Usually, you want to specify your details outside of the role so that you can easily share the role structure without worrying about leaking information. Also, variables declared within a role are easily overridden by variables in other locations, so they are not very strong to begin with.

By now, you may be wondering why we have to organize our information into directories, when most of our directories only contain a single main.yml file. Why aren't we creating tasks.yml files instead of tasks/main.yml?

The answer is that we are only using the minimum amount of files. The main.yml files are the ones picked up automatically by Ansible, but we can include additional files easily by using the include functionality.

If we had an additional task file used to configure SSL for some of our hosts located at tasks/ssl.yml, we could call it like this:


		#
		#
		. . .
		tasks:
		  - include: roles/nginx/tasks/ssl.yml


Create a Skeleton Playbook
+++

Now that we have configured our role structure, we can call all of the functionality with a very simple playbook.

This allows us to use playbooks to declare what a server is supposed to do, not what steps must happen to make it behave how we want it to.

Outside of the entire role structure, in our working directory (our home directory in this example), we can create a playbook file.


		#
		cd ~
		nano play.yml


Inside of this file, we need very little information. First, we have not defined any hosts, so that goes here. Next, we just declare the role we are using:


		#
		#
		---
		- hosts: droplets
		  roles:
			- role: nginx


Save and close the file. This is our entire playbook. As you can see, it cleans everything up and allows us to concentrate on core functionality. If we had multiple roles configured, we could simply list what different things we want our server to do.

For instance, if we had roles to set up a WordPress server, we might have a playbook that looks like this:


		#
		#
		---
		- hosts: wordpress_hosts
		  roles:
			- nginx
			- php
			- mysql
			- wordpress


As you can see, this allows us to be very succinct about what we want from a server. Since in the end, we use a playbook to call a role, the command syntax is exactly the same:


$ ansible-playbook play.yml
---


Conclusion

Ansible roles are an optional feature to take advantage of, but if you plan on using Ansible extensively, it is highly recommended that you explore this functionality. Not only will it keep your host-level configuration clean and readable, it will also allow you to easily reuse code and implement your changes in a modular fashion.


Comments
+++

February 28, 2014

Great article, but you are missing "defaults" directory in which you can add default values for variables which basically get overridden by everything else. 





Title: how-to-create-an-ansible-playbook-to-automate-drupal-installation-on-ubuntu-14-04
===
Source: https://www.digitalocean.com/community/tutorials/how-to-create-an-ansible-playbook-to-automate-drupal-installation-on-ubuntu-14-04

Added: Fri Dec  2 19:42:42 CET 2016
Created: PostedDecember 23, 2014


Introduction
+++

Ansible is a configuration management tool that system administrators use to automate infrastructure management activities.

Ansible uses only SSH to run commands remotely, and thus does not need an agent on the remote server. This makes Ansible preferable over other popular tools like Puppet or Chef when you don't want to install agents on the managed servers.

Moreover, it is much easier to get started with Ansible because it uses YAML (Yet Another Markup Language) which is simpler than the more powerful programming languages that other tools use.

Drupal is a popular CMS whose installation is time-consuming, but easy to automate. In this tutorial, we are going to create an Ansible Playbook that automates the installation and configuration of Drupal and all its dependencies on systems that run Ubuntu 14.04. 


Prerequisites
+++

You will need the following:

    - Ubuntu 14.04 server (which is accessible over SSH); this server will run Ansible and a local copy of Drupal
    - Optional: Additional Ubuntu 14.04 servers where you want to install Drupal
    - A sudo user on each server; you should use the same username and same password for each server where you want to install Drupal
    - A basic understanding of how a Drupal installation works. You can refer to How To Install Drupal on an Ubuntu 14.04 Server with Apache, although you do not need to pre-install Drupal



Step 1  Install Ansible
+++

Update the package lists.
Install Ansible.


		#
		sudo apt-get update
		sudo apt-get install ansible


Step 2  Create a Directory for the Playbook
+++

Ansible's instruction sets are called playbooks. It's a good idea to store all your playbooks in a single directory. Create a directory named MyPlaybooks.


		#
		mkdir ~/MyPlaybooks


Let us name our playbook drupal_setup. Create a new directory named drupal_setup.


		#
		mkdir ~/MyPlaybooks/drupal_setup


Step 3  Create a hosts File
+++

Each playbook usually has a hosts file that contains names of the servers that it should use.

In this tutorial, we are going to install Drupal on localhost and one other server, drupal_server. You are free to add more servers to this file. Remember, every server you add should be accessible over SSH.

Use nano to create and edit a file named hosts.


		#
		nano ~/MyPlaybooks/drupal_setup/hosts

Let it have the following contents:


		#
		[drupal_hosts]
		localhost
		drupal_server_ip

MY_NOTE:
I created the "hosts" file with the following content.


		#
		[drupal_hosts]
		test_machine ansible_host=127.0.0.1 ansible_port=2222 ansible_user=vagrant

You should replace drupalserverip with your second server's IP address. You can list as many IP addresses here as you want; you can use this playbook to install Drupal on any number of Ubuntu 14.04 servers.


    Note: The hosts file is the file you should update if you want to reuse this playbook in the future to configure more Drupal servers. Note that you should remove the already-configured servers from the list, and add your new server IPs, before you re-run the playbook.

Save and close the file.


Step 4  Create a Role to apt-get update
+++

Create a new directory to store all the roles of the Playbook.


		#
		mkdir ~/MyPlaybooks/drupal_setup/roles


We need to apt-get update the servers before doing anything else, so create a directory for the role update.


		#
		mkdir ~/MyPlaybooks/drupal_setup/roles/update


Each role has one or more tasks. Create a directory named tasks to hold all tasks associated with this role.


		#
		mkdir ~/MyPlaybooks/drupal_setup/roles/update/tasks


Use nano to create and edit a new task file named main.yml. This is the file that tells Ansible what to do when it executes this role.


		#
		nano ~/MyPlaybooks/drupal_setup/roles/update/tasks/main.yml


In this file, use Ansible's apt module to update the system:


		#
		#
		---
		- name: apt-get update the server
		  apt: update_cache=yes


Make sure your file doesn't have any extra whitespace; Ansible is picky about this. Save and close the file.


Step 5 â€” Create a Role to Set Up PHP
+++

Create a directory for the role php.


		#
		mkdir ~/MyPlaybooks/drupal_setup/roles/php

Create the tasks directory for this role:


		#
		mkdir ~/MyPlaybooks/drupal_setup/roles/php/tasks


Drupal needs a web server which is configured to use PHP. In this tutorial, we use Apache. When we install PHP, Apache is installed automatically, so we don't need any extra commands for it.

Use nano to create and edit the main.yml for the php role.


		#
		nano ~/MyPlaybooks/drupal_setup/roles/php/tasks/main.yml


Use Ansible's apt module to install PHP5 (and the packages it depends on), and the PHP5 GD library. Add the following to the file:


		#
		#
		---
		- name: Install PHP and associated packages
		  apt: name=php5 state=latest

		- name: Install PHP GD library
		  apt: name=php5-gd state=latest
		  notify:
			- Restart Apache


Apache has to be restarted after the PHP GD library is installed. Therefore, this role also needs a handler.

All handlers of a role are stored in a separate directory. Create a directory named handlers for the current role.


		#
		mkdir ~/MyPlaybooks/drupal_setup/roles/php/handlers


Use nano to create and edit the main.yml file.


		#
		nano ~/MyPlaybooks/drupal_setup/roles/php/handlers/main.yml

Add the following code to it:


		#
		#
		---
		- name: Restart Apache
		  service: name=apache2 state=restarted

You're done with the PHP and Apache setup.



Step 6  Create a Role to Set Up MySQL
+++

Drupal needs a database to store settings and content. In this tutorial, we use MySQL.

Create directories for this role and its tasks.


		#
		mkdir -p ~/MyPlaybooks/drupal_setup/roles/mysql/tasks


The first task of this role installs MySQL and its dependencies. Use nano to create and edit a file named setup.yml.


		#
		nano ~/MyPlaybooks/drupal_setup/roles/mysql/tasks/setup.yml


In this file, we will tell Ansible to use the apt module again to install:


    - mysql-server
    - libapache2-mod-auth-mysql
    - php5-mysql


So, add the following to the file:


		#
		#
		---
		- name: Install MySQL server
		  apt: name=mysql-server state=latest

		- name: Install Apache module for MySQL authentication
		  apt: name=libapache2-mod-auth-mysql state=latest

		- name: Install MySQL module for PHP
		  apt: name=php5-mysql state=latest


Our role has one more tasks file. As Drupal needs its own MySQL database and database user, we will create a separate tasks file to create them. Use nano to create and edit a file named create_db.yml.


		#
		nano ~/MyPlaybooks/drupal_setup/roles/mysql/tasks/create_db.yml


Ansible has modules that let you manage MySQL. In this task, we will use the following modules:


    - mysql_db - To create a new database for Drupal.
    - mysql_user To create a new user and allow it to access the database.


Before we use mysql_db or mysql_user we should make sure that the Python MySQLdb package is installed on the remote host. Use the apt module to install it.

Add the following contents to the file:


		#
		#
		---
		- name: Install Python MySQLdb
		  apt: name=python-mysqldb state=latest

		- name: Create the Drupal database
		  mysql_db: db={{ db_name }} state=present

		- name: Create the Drupal user
		  mysql_user: >
			name={{ db_user }}
			password={{ db_password }}
			priv={{ db_name }}.*:ALL
			host=localhost


Note that strings enclosed in {{ }} denote variables. In this task, we have the variables {{ db_user }}, {{ db_password}} and {{ db_name }}. We are going to set the values of these variables in a later step.

Next, we need to let Ansible know that this role has two tasks. To do this, we create a main.yml file.


		#
		nano ~/MyPlaybooks/drupal_setup/roles/mysql/tasks/main.yml


Add the following code to this file:


		#
		#
		---
		- include: setup.yml
		- include: create_db.yml


Step 7  Create a Role to Install Drupal
+++

It's now time to move on to the installation of Drupal itself.

Create directories for this role and its tasks.


		#
		mkdir -p ~/MyPlaybooks/drupal_setup/roles/drupal/tasks


Use nano to create and edit a task file named main.yml.


		#
		nano ~/MyPlaybooks/drupal_setup/roles/drupal/tasks/main.yml


In this task, we will tell Ansible to perform the following actions:



    - Install git on the remote host. This is necessary because we will be using Ansible's git module
    - Use Ansible's git module to clone the latest stable version of Drupal from its repository at http://git.drupal.org/project/drupal.git. The downloaded files are placed in /var/www/html/drupal
    - Create the settings.php and services.yml files from the default files
    - Update the permissions of settings.php, services.yml, and sites/default/files


Add the following code to the file:


		#
		#
		---

		- name: Install git
		  apt: name=git state=latest

		- name: Clone Drupal
		  git: >
			repo=http://git.drupal.org/project/drupal.git
			dest=/var/www/html/drupal/
			update=no

		- name: Create settings.php
		  command: cp /var/www/html/drupal/sites/default/default.settings.php /var/www/html/drupal/sites/default/settings.php

		- name: Create services.yml
		  command: cp /var/www/html/drupal/sites/default/default.services.yml /var/www/html/drupal/sites/default/services.yml

		- name: Update permissions of settings.php
		  file: path=/var/www/html/drupal/sites/default/settings.php mode=777

		- name: Update permissions of services.yml
		  file: path=/var/www/html/drupal/sites/default/services.yml mode=777

		- name: Update permissions of files directory
		  file: >
			path=/var/www/html/drupal/sites/default/files
			mode=777
			state=directory
			recurse=yes



You'll want to update the permissions for these files later after completing the browser installations on each server (on each server, rather than through Ansible).


Step 8  Create a File to Use All the Roles
+++


At this point, all our roles are ready. We now need to use them.

Use nano to create a file named site.yml. This is the file we will actually run with Ansible.


		#
		nano ~/MyPlaybooks/drupal_setup/site.yml


In this file we perform the following activities:

    - Specify the hosts that this Playbook will run on
    - Specify that sudo should be used to run all tasks of this Playbook
    - Set default values to variables used in various roles
    - Run all the roles

Add the following code to it:


		#
		#
		---
		- hosts: drupal_hosts
		  sudo: yes
		  vars:
			- db_name: drupal
			- db_user: drupal_user
			- db_password: drupal_db_pass
		  roles:
			- update
			- php
			- mysql
			- drupal


Make sure you change the value of the variable db_password to something other than drupal_db_pass. You are free to change the values of the other two variables as well to match your preferences.


Step 9  Establish an SSH Connection
+++


Before you run the Playbook, your ~/.ssh/known_hosts file should have an entry for each of the hosts mentioned in the hosts file.

An easy way to do this is to connect once to each server listed in the ~/MyPlaybooks/drupal_setup/hosts file from this server, using SSH.

Connect to localhost via SSH using the command:


		#
		ssh localhost


If this is the first time you are connecting to the server this way, you will be prompted with a message that says:


		#
		The authenticity of host 'localhost (127.0.0.1)' can't be established.
		ECDSA key fingerprint is b1:18:3d:19:15:21:39:5a:f7:9f:3c:37:68:ba:62:01.
		Are you sure you want to continue connecting (yes/no)?


Once you say yes, you will get a message saying:


		#
		Warning: Permanently added 'localhost' (ECDSA) to the list of known hosts.


Connect to any other servers listed in the hosts file:


		#
		ssh drupal_sudo_user@drupal_server_ip



Make sure you replace the username and IP address with the actual information for each server. Please keep in mind that the sudo username (drupal_sudo_user in the example) and password should be the same for each server, including localhost.

    Note: Instead of using passwords, you could copy the SSH public key for the Ansible server's sudo user to the drupal_sudo_user's authorized_keys file on each managed server.

Once you have connected to each server, you are ready to run the playbook.


Step 10  Run the Playbook
+++


The Playbook is now ready to be tested. Fire it off using the ansible-playbook command. The -k option forces Ansible to ask for the SSH password, and is not necessary if you have set up passwordless authentication. The -K option forces Ansible to ask for the sudo password.


		#
		cd ~/MyPlaybooks/drupal_setup/


$ ansible-playbook -i hosts site.yml -kK
---


Step 11  Set Up Drupal
+++

Now, you will be able to use a browser to access Drupal and complete the browser-based installation, at 


		#
		http://your_server_ip/drupal/.

Drupal Setup Page

If you need help with completing the browser installer for Drupal, follow along with the instructions in this article.

Your database settings will be the variables you set in the vars section of the ~/MyPlaybooks/drupal_setup/site.yml file.

Double-check that each server has a successful Drupal installation.



Step 12  Clean Up the Host List
+++

Now's a good time to remove the hosts from the ~/MyPlaybooks/drupal_setup/hosts file. That way, if you run the playbook again, you won't accidentally overwrite the hosts that you have already set up.


Troubleshooting
+++

Note that YAML is whitespace-sensitive. If you are having trouble with your playbook, you probably have improper indentation or extra spaces in your .yml files.

If you see an error that looks like:


		#
		fatal: [server-name] => Using a SSH password instead of a key is not possible because Host Key checking is enabled and sshpass does not support this.  Please add this host's fingerprint to your known_hosts file to manage this host.



This means you missed adding an entry for one or more hosts in the ~/.ssh/known_hosts file.

You'll need to make a manual SSH connection to localhost or to the target remote server first. Then try running the playbook again.



Conclusion


With this tutorial, you have learned to create an Ansible playbook that sets up Drupal for you, along with Apache and MySQL. Before you use this playbook in production systems, you will have to further build on it to make the installation more secure. You could also use Drush commands in the playbook to manage the Drupal installation.


Comments
+++

December 5, 2015

using ansible-galaxy to generate your role folders and their sub folders makes this way easier than creating each by hand... it can simply generate a role and all subfolders with a command like:


$ ansible-galaxy init drupal
---
or

$ ansible-galaxy init mysql
---




Title: how-to-configure-apache-using-ansible-on-ubuntu-14-04
===
Source: https://www.digitalocean.com/community/tutorials/how-to-configure-apache-using-ansible-on-ubuntu-14-04

Added: Sat Dec  3 14:04:12 CET 2016
Created: PostedFebruary 18, 2015


Introduction
+++

Apache is one of the most popular web servers currently used on the Internet. It is easy to set up and configure on Linux distributions like Ubuntu and Debian, as it comes in the package repositories and includes a default configuration that works out of the box.


Ansible is an automation tool that allows you to remotely configure systems, install software, and perform complex tasks across a large fleet of servers without needing to manually log into each. Unlike other alternatives, Ansible is installed on a single host, which can even be your local machine, and uses SSH to communicate with each remote host. This allows it to be incredibly fast at configuring new servers, as there are no prerequisite packages to be installed on each new server. It is incredibly easy to use and understand, since it uses playbooks in yaml format using a simple module based syntax.


Prerequisites
+++

For this tutorial, we will install Ansible on a new Ubuntu 14.04 master Droplet and use it to configure Apache on a second Droplet. That said, keep in mind that one of the benefits of Ansible is that you can have it installed on your local machine and manage other hosts without needing to manually ssh into them.

For this tutorial, you will need:

    - Two Ubuntu 14.04 Droplets: one master Droplet with Ansible and one secondary Droplet which will run Apache configured through Ansible
    - Sudo non-root users for both Droplets.
    - Ansible installed on the master Droplet. Follow this tutorial (up to the Set Up SSH Keys section). Although that tutorial was written for Ubuntu 12.04, it is still relevant for Ubuntu 14.04.
    - SSH keys for the master Droplet to authorize login on the secondary Droplet, which you can do following this tutorial on the master Droplet.
    - Active DNS records, or manually set up a local hosts file on your local machine (using your secondary Droplet's IP address), in order to set up and use the Virtual Hosts that will be configured.




Note: This tutorial follows the concepts explained in the existing tutorial:
How To Configure the Apache Web Server on an Ubuntu or Debian VPS. Please review that tutorial if you would like more information, or would like to review the manual process alongside the Ansible process.


Step 1  Configuring Ansible
+++

In this section we will configure Ansible to be able to manage your server.

The first step, once Ansible is installed, is to tell Ansible which hosts to talk to. To do this, we need to create an Ansible hosts file. The Ansible hosts file contains groups of hosts, which we refer to when running Ansible commands. By default this is located in /etc/ansible/hosts. However, that is applied globally across your system and often requires admin permissions. Instead, to make things simpler, we need to tell Ansible to use a local hosts file.


Ansible always looks for an ansible.cfg file in the local directory that it is being run from, and if found will override the global configuration with the local values. With this in mind, all we need to do is tell Ansible that we want to use a hosts file in the local directory, rather than the global one.

Create a new directory (which we will use for the rest of this tutorial).


		#
		mkdir ansible-apache

Move into the new directory.


		#
		cd ~/ansible-apache/


Create a new file called ansible.cfg and open it for editing.


		#
		nano ansible.cfg


Within that file, we want to add in the hostfile configuration option with the value of hosts, within the [defaults] group. Copy the following into the ansible.cfg file, then save and close it.


		#
		[defaults]
		hostfile = hosts


Next, the hosts file needs to be written. There are a lot of options available for the hosts file. However, we can start with something very simple.

Create a hosts file and open it for editing.


		#
		nano hosts

Copy the following into the hosts file.


		#
		[apache]
		secondary_server_ip ansible_ssh_user=username


This specifies a host group called apache which contains one host. Replace secondary_server_ip with the secondary server's hostname or IP address, and username with your SSH username. Now Ansible should be able to connect to your server.

Note: The ansible_ssh_user=username component is optional if you are running Ansible as the same user as the target host.


To test that Ansible is working and can talk to your host, you can run a basic ansible command. Ansible comes with a lot of default modules, but a good place to start is the ping module. It checks it can connect to each host, which makes checking the hosts file for correctness easy.

Basic usage of the ansible command accepts the host group, and the module name: ansible <group> -m <module>. To run the ping command, enter the following command.


$ ansible apache -m ping
---

The output should look like this:


		#
		111.111.111.111 | success >> {
			"changed": false,
			"ping": "pong"
		}



Another Ansible module that is useful for testing is the command module. It runs custom commands on the host and returns the results. To run the command command using echo, a Unix command that echoes a string to the terminal, enter the following command.


$ ansible apache -m command -a "/bin/echo hello sammy"
---


The output should look like this:


		#
		111.111.111.111 | success | rc=0 >>
		hello sammy


This is basic usage of Ansible. The real power comes from creating playbooks containing multiple Ansible tasks. We will cover those next.



Step 2  Creating a Playbook
+++

In this section we will create a basic Ansible playbook to allow you to run more complicated modules easily.

A very basic Ansible playbook is a single yaml file which specifies the host group and one or more tasks to be run on the hosts within the specified group. They are quite simple and easy to read, which is one of the reasons why Ansible is so powerful.

Let's create a basic playbook version of the hello sammy command above.

Create a file called apache.yml and open it for editing.


		#
		nano apache.yml


Copy the following text into the file, then save and close it.


		#
		#
		---
		- hosts: apache
		  tasks:
			- name: run echo command
			  command: /bin/echo hello sammy



The hosts: apache declaration is at the top, which tells Ansible that we are using the apache hosts group. This is the equivalent of passing it via the ansible command. Next there is a list of tasks. In this example, we have one task with the name run echo command. This is simply a description intended for the user to understand what the task is doing. Finally, the command: /bin/echo hello sammy line runs the command module with the arguments /bin/echo hello sammy.



The ansible-playbook command is used to run playbooks, and the simplest usage is: ansible-playbook your-playbook.yml. We can run the playbook we just created with the following command.


$ ansible-playbook apache.yml
---

The output should look like this.


		#
		PLAY [apache] *****************************************************************

		GATHERING FACTS ***************************************************************
		ok: [111.111.111.111]

		TASK: [run echo command] ******************************************************
		changed: [111.111.111.111]

		PLAY RECAP ********************************************************************
		111.111.111.111            : ok=2    changed=1    unreachable=0    failed=0



The most important thing to notice here is that playbooks do not return the output of the module, so unlike the direct command we used in Step 1, we cannot see if hello sammy was actually printed. This means that playbooks are better suited for tasks where you don't need to see the output. Ansible will tell you if there was an error during the execution of a module, so you generally only need to rely on that to know if anything goes wrong.


Step 3  Installing Apache
+++


Now that we have introduced playbooks, we will write the task to install the Apache web server.

Normally on Ubuntu, installing Apache is a simple case of installing the apache2 package via apt-get. To do this via Ansible, we use Ansible's apt module. The apt module contains a number of options for specialised apt-get functionality. The options we are interested in are:

    - name: The name of the package to be installed, either a single package name or a list of packages.
    - state: Accepts either latest, absent, or present. Latest ensures the latest version is installed, present simply checks it is installed, and absent removes it if it is installed.
    - update_cache: Updates the cache (via apt-get update) if enabled, to ensure it is up to date.

Note: Package managers other than apt have modules too. Each module page has examples that usually cover all of the main use cases, making it very easy to get a feel for how to use each module. It is rare to have to look elsewhere for usage instructions.

Now let's update our apache.yml playbook with the apt module instead of the command module. Open up the apache.yml file for editing again.


		#
		nano apache.yml

Delete the text currently there and copy the following text into it.


		#
		#
		---
		- hosts: apache
		  sudo: yes
		  tasks:
			- name: install apache2
			  apt: name=apache2 update_cache=yes state=latest



The apt line installs the apache2 package (name=apache2) and ensures we have updated the cache (update_cache=yes). Although it is optional, including state=latest to be explicit that it should be installed is a good idea.

Unless your Playbook is running as root on each host, sudo will be required to ensure the right privileges. Ansible supports sudo as part of a simple option within the Playbook. It can also be applied via the ansible-playbook command and on a per-task level.


Now run the playbook.

$ ansible-playbook apache.yml --ask-sudo-pass
---


The --ask-sudo-pass flag will prompt you for the sudo password on the secondary Droplet. This is necessary because the installation requires root privileges; the other commands we've run so far did not.

The output should look like this.


		#
		PLAY [apache] *****************************************************************

		GATHERING FACTS ***************************************************************
		ok: [111.111.111.111]

		TASK: [install apache2] *******************************************************
		changed: [111.111.111.111]

		PLAY RECAP ********************************************************************
		111.111.111.111            : ok=2    changed=1    unreachable=0    failed=0



If you visit your secondary server's hostname or IP address in your browser, you should now get a Apache2 Ubuntu Default Page to greet you. This means you have a working Apache installation on your server, and you haven't manually connected to it to run a command yet.

An important concept to note at this point is idempotence, which underlies how Ansible modules are supposed to behave. The idea is that you can run the same command repeatedly, but if everything was configured on the first run, then all subsequent runs make no changes. Almost all Ansible modules support it, including the apt module.

For example, run the same playbook command again.


The output should look like this. Note the changed=0 section.


		#
		PLAY [apache] *****************************************************************

		GATHERING FACTS ***************************************************************
		ok: [111.111.111.111]

		TASK: [install apache2] *******************************************************
		ok: [111.111.111.111]

		PLAY RECAP ********************************************************************
		111.111.111.111            : ok=2    changed=0    unreachable=0    failed=0




This tells you that the apache2 package was already installed, so nothing was changed. When dealing with complicated playbooks across many hosts, being able to identify the hosts that were different becomes very useful. For example, if you notice a host always needs a specific config updated, then there is likely a user or process on that host which is changing it. Without idempotence, this may never be noticed.


Step 4  Configuring Apache Modules
+++

Now that Apache is installed, we need to enable a module to be used by Apache.

Let us make sure that the mod_rewrite module is enabled for Apache. Via SSH, this can be done easily by using a2enmod and restarting Apache. However, we can also do it very easily with Ansible using the apache2_module module and a task handler to restart apache2.

The apache2_module module takes two options:

     - name  The name of the module to enable, such as rewrite.
     - state  Either present or absent, depending on if the module needs to be enabled or disabled.

Open apache.yml for editing.


Update the file to include this task. The file should now look like this:


		#
		#
		---
		- hosts: apache
		  sudo: yes
		  tasks:
			- name: install apache2
			  apt: name=apache2 update_cache=yes state=latest

			- name: enabled mod_rewrite
			  apache2_module: name=rewrite state=present


However, we need to restart apache2 after the module is enabled. One option is to add in a task to restart apache2, but we don't want that to run every time we apply our playbook. To get around this, we need to use a task handler. The way handlers work is that a task can be told to notify a handler when it has changed, and the handler only runs when the task has been changed.

To do this we need to add the notify option into the apache2_module task, and then we can use the service module to restart apache2 in a handler.


That results in a playbook that looks like this:


		#
		#
		---
		- hosts: apache
		  sudo: yes
		  tasks:
			- name: install apache2
			  apt: name=apache2 update_cache=yes state=latest

			- name: enabled mod_rewrite
			  apache2_module: name=rewrite state=present
			  notify:
				- restart apache2

		  handlers:
			- name: restart apache2
			  service: name=apache2 state=restarted


Now, rerun the playbook.


$ ansible-playbook apache.yml --ask-sudo-pass
---

The output should look like:



		#
		PLAY [apache] *****************************************************************

		GATHERING FACTS ***************************************************************
		ok: [111.111.111.111]

		TASK: [install apache2] *******************************************************
		ok: [111.111.111.111]

		TASK: [enabled mod_rewrite] ***************************************************
		changed: [111.111.111.111]

		NOTIFIED: [restart apache2] ***************************************************
		changed: [111.111.111.111]

		PLAY RECAP ********************************************************************
		111.111.111.111            : ok=4    changed=2    unreachable=0    failed=0



It looks good so far. Now, run the command again and there should be no changes, and the restart task won't be listed.




Step 5  Configuring Apache Options
+++

Now that we have a working Apache installation, with our required modules turned on, we need to configure Apache.

By default Apache listens on port 80 for all HTTP traffic. For the sake of the tutorial, let us assume that we want Apache to listen on port 8081 instead. With the default Apache configuration on Ubuntu 14.04 x64, there are two files that need to be updated:


		#
		/etc/apache2/ports.conf
			Listen 80

		#
		/etc/apache2/sites-available/000-default.conf
			<VirtualHost *:80>


To do this, we can use the lineinfile module. This module is incredibly powerful and through the use of it's many different configuration options, it allows you to perform all sorts of changes to an existing file on the host. For this example, we will use the following options:



    - dest  The file to be updated as part of the command.
    - regexp  Regular Expression to be used to match an existing line to be replaced.
    - line  The line to be inserted into the file, either replacing the regexp line or as a new line on the end.
    - state  Either present or absent.


Note: The lineinfile module will append the line on the end of the file if it doesn't match an existing line with the regexp. The options insertbefore and insertafter can specify lines to add it before or after instead of at the end, if needed.

What we need to do to update the port from 80 to 8081 is look for the existing lines which define port 80, and change them to define port 8081. 


Open the apache.yml file for editing.


Amend the additional lines so that the file looks like this:


		#
		#
		---
		- hosts: apache
		  sudo: yes
		  tasks:
			- name: install apache2
			  apt: name=apache2 update_cache=yes state=latest

			- name: enabled mod_rewrite
			  apache2_module: name=rewrite state=present
			  notify:
				- restart apache2

			- name: apache2 listen on port 8081
			  lineinfile: dest=/etc/apache2/ports.conf regexp="^Listen 80" line="Listen 8081" state=present
			  notify:
				- restart apache2

			- name: apache2 virtualhost on port 8081
			  lineinfile: dest=/etc/apache2/sites-available/000-default.conf regexp="^<VirtualHost \*:80>" line="<VirtualHost *:8081>" state=present
			  notify:
				- restart apache2

		  handlers:
			- name: restart apache2
			  service: name=apache2 state=restarted


It is important to notice that we also need to restart apache2 as part of this process, and that we can re-use the same handler but the hanlder will only be triggered once despite multiple changed tasks.


Now run the playbook.


$ ansible-playbook apache.yml --ask-sudo-pass
---


Once Ansible has finished, you should be able to visit your host in your browser and it will respond on port 8081, rather than port 80. In most web browsers, this can be easily achieved by adding :port onto the end of the URL: http://111.111.111.111:8081/.


The lineinfile module is very powerful, and makes mangling existing configurations really easy. The only catch is that you need to know what to expect in the files you are changing with it, but it supports a wide variety of options that support most simple use cases.


Step 6  Configuring Virtual Hosts
+++

Ansible features a couple of modules that provide the ability to copy a local (to Ansible) template file onto the hosts. The two most commonly used modules for this purpose are the copy module and the template module. The copy module copies a file as-is and makes no changes to it, whereas the more powerful template module copies across a template and applies variable substitution to areas you specify by using double curly brackets (i.e. {{ variable }}).

In this section we will use the template module to configure a new virtual host on your server. There will be a lot of changes, so we'll explain them piece by piece, and include the entire updated apache.yml file at the end of this step.


Create Virtual Host Configuration
---

The first step is to create a new virtual host configuration. We'll create the virtual host configuration file on the master Droplet and upload it to the secondary Droplet using Ansible.

Here's an example of a basic virtual host configuration which we can use as a starting point for our own configuration. Notice that both the port number and the domain name, hilighted below, are hardcoded into the configuration.


		#
		#
		<VirtualHost *:8081>
			ServerAdmin webmaster@example.com
			ServerName example.com
			ServerAlias www.example.com
			DocumentRoot /var/www/example.com
			ErrorLog ${APACHE_LOG_DIR}/error.log
			CustomLog ${APACHE_LOG_DIR}/access.log combined
		</VirtualHost>



Create a new file called virtualhost.conf.


		#
		nano virtualhost.conf


Paste the following into virtualhost.conf. Because we are using templates, it is a good idea to change the hard coded values above to variables, to make them easy to change in the future.


		#
		<VirtualHost *:{{ http_port }}>
			ServerAdmin webmaster@{{ domain }}
			ServerName {{ domain }}
			ServerAlias www.{{ domain }}
			DocumentRoot /var/www/{{ domain }}
			ErrorLog ${APACHE_LOG_DIR}/error.log
			CustomLog ${APACHE_LOG_DIR}/access.log combined
		</VirtualHost>


Use Template Variables
---

Next, we need to update our playbook to push out the template and use the variables.

The first step is to add in a section into the playbook for variables. It is called vars and goes on the same level as hosts, sudo, tasks, and handlers. We need to put in both variables used in the template above, and we will change the port back to 80 in the process.


		#
		#
		---
		- hosts: apache
		  sudo: yes
		  vars:
			http_port: 80
			domain: example.com
		  tasks:
			- name: install apache2
		...



Variables can be used in tasks and templates, so we can update our existing lineinfile modules to use the specified http_port, rather than the hard coded 8081 we specified before. The variable needs to be added into the line, and the regexp option needs to be updated so it's not looking for a specific port. The changes will look like this:


		#
		lineinfile: dest=/etc/apache2/ports.conf regexp="^Listen " line="Listen {{ http_port }}" state=present
		lineinfile: dest=/etc/apache2/sites-available/000-default.conf regexp="^<VirtualHost \*:" line="<VirtualHost *:{{ http_port }}>"



Add Template Module
---


The next step is to add in the template module to push the configuration file onto the host. We will use these options to make it happen:

    - dest The destination file path to save the updated template on the host(s), i.e. /etc/apache2/sites-available/{{ domain }}.conf.
    - src The source template file, i.e. virtualhost.conf.


Applying these to your playbook will result in a task that looks like this:


		#
		- name: create virtual host file
		  template: src=virtualhost.conf dest=/etc/apache2/sites-available/{{ domain }}.conf




Enable the Virtual Host
---

Almost done! What we need to do now is enable the virtual host within Apache. This can be done in two ways: by running the sudo a2ensite example.com command or manually symlinking the config file into /etc/apache2/sites-enabled/. The former option is safer, as it allows Apache to control the process. For this, the command module comes in use again.

The usage is quite simple, as we discovered above:


		#
		- name: a2ensite {{ domain }}
		  command: a2ensite {{ domain }}
		  notify:
		  - restart apache2


Prevent Extra Work
---

Finally, the command module needs to know when it should and shouldn't run, so the module is not run unnecessarily if the playbook is run multiple times. In our case, it only needs to be run if the .conf file hasn't been created on the host yet.

This is done using the creates option, which allows you to tell the module what file is being created during the module execution. If the file exists, the module won't run. Because Apache creates a symlink when sites are enabled, checking for that solves the problem.


The changes will look like this:


		#
		- name: a2ensite {{ domain }}
		  command: a2ensite {{ domain }}
		  args:
			creates: /etc/apache2/sites-enabled/{{ domain }}.conf
		  notify:
		  - restart apache2


It is important to note the use of the args section in the task. This is an optional way of listing the module options, and in this case removes any confusion between what is a module option and what is the command itself.


Final apache.yml Playbook
+++

With all of the changes above, change your apache.yml playbook to look like this.


		#
		#
		---
		- hosts: apache
		  sudo: yes
		  vars:
			http_port: 80
			domain: example.com
		  tasks:
			- name: install apache2
			  apt: name=apache2 update_cache=yes state=latest

			- name: enabled mod_rewrite
			  apache2_module: name=rewrite state=present
			  notify:
				- restart apache2

			- name: apache2 listen on port {{ http_port }}
			  lineinfile: dest=/etc/apache2/ports.conf regexp="^Listen " line="Listen {{ http_port }}" state=present
			  notify:
				- restart apache2

			- name: apache2 virtualhost on port {{ http_port }}
			  lineinfile: dest=/etc/apache2/sites-available/000-default.conf regexp="^<VirtualHost \*:" line="<VirtualHost *:{{ http_port }}>"
			  notify:
				- restart apache2

			- name: create virtual host file
			  template: src=virtualhost.conf dest=/etc/apache2/sites-available/{{ domain }}.conf

			- name: a2ensite {{ domain }}
			  command: a2ensite {{ domain }}
			  args:
				creates: /etc/apache2/sites-enabled/{{ domain }}.conf
			  notify:
				- restart apache2

		  handlers:
			- name: restart apache2
			  service: name=apache2 state=restarted


Save and close the file, then run the playbook.

$ ansible-playbook apache.yml --ask-sudo-pass
---

If you now visit the hostname or IP address of your secondary Droplet in your browser, you will see it responds on port 80 again, not port 8081. Next, visit the domain (i.e. example.com) we specified for the new virtual host. Because we haven't added any files in yet, it should show an Apache 404 error page rather than the Apache welcome page. If so, your virtual host is working correctly, and you still haven't SSH'ed into your secondary Droplet to run a single command.



Step 7  Using a Git Repository For Your Website
+++


In this section we will use Ansible to clone a Git repository in order to set up your website content.

Every website needs content, and although it is normal to SSH in and manually clone a Git repository to set up a new website, Ansible provides us with the tools we need to do it automatically. For this example, the git module will do what is required.

The git module has a lot of options, with the relevant ones for this tutorial being:


    - dest -- The path on the host where the repository will be checked out to.
    - repo -- The repository url that will be cloned. This must be accessible by the host.
    - update -- When set to no, this prevents Ansible from updating the repository when it already exists.
    - accept_hostkey -- Tells SSH to accept any unknown host key when connecting via SSH. This is very useful as it saves the need to login via SSH to accept the first login attempt, but it does remove the ability to manually check the host signature. Depending on your repository, you may need this option.



For the purposes of the tutorial, there is a simple Git repository with a single index.html page that can be cloned onto your host. If you already have another public repository that contains similar, feel free to substitute it. With that in mind, the git task will look like this:


		#
		- name: clone basic html template
		  git: repo=https://github.com/do-community/ansible-apache-tutorial.git dest=/var/www/example.com update=no


However, if you ran the Playbook now, you would probably get an error. We first need to install the git package so Ansible can use it to clone the repository. The apt task needs to be updated to install both the apache2 package and the git package. Checking the apt documentation tells us that the name option only takes a single package, so that won't help. Instead, we need to use a list of items.

Ansible provides the ability to specify a list of items to loop through and apply the task to each. They are specified using the with_items option as part of the task, and our apt task will be updated to look like this:


		#
		- name: install packages
		  apt: name={{ item }} update_cache=yes state=latest
		  with_items:
			- apache2
			- git



The list of items uses the item variable and will execute the task for each item in the list.


Open apache.yml again.

Update the playbook to match the following:


		#
		#
		---
		- hosts: apache
		  sudo: yes

		  vars:
			http_port: 80
			domain: example.com

		  tasks:

			- name: install packages
			  apt: name={{ item }} update_cache=yes state=latest
			  with_items:
				- apache2
				- git

			- name: enabled mod_rewrite
			  apache2_module: name=rewrite state=present
			  notify:
				- restart apache2

			- name: apache2 listen on port {{ http_port }}
			  lineinfile: dest=/etc/apache2/ports.conf regexp="^Listen " line="Listen {{ http_port }}" state=present
			  notify:
				- restart apache2

			- name: apache2 virtualhost on port {{ http_port }}
			  lineinfile: dest=/etc/apache2/sites-available/000-default.conf regexp="^<VirtualHost \*:" line="<VirtualHost *:{{ http_port }}>"
			  notify:
				- restart apache2

			- name: create virtual host file
			  template: src=virtualhost.conf dest=/etc/apache2/sites-available/{{ domain }}.conf

			- name: a2ensite {{ domain }}
			  command: a2ensite {{ domain }}
			  args:
				creates: /etc/apache2/sites-enabled/{{ domain }}.conf
			  notify:
				- restart apache2

			- name: clone basic html template
			  git: repo=https://github.com/do-community/ansible-apache-tutorial.git dest=/var/www/example.com update=no

		  handlers:
			- name: restart apache2
			  service: name=apache2 state=restarted



Save the file and run the playbook.

ansible-playbook apache.yml --ask-sudo-pass

It should install git and successfully clone the repository. You should now see something other than a 404 error when you visit the virtual host from Step 6. Don't forget to check the non virtual host is still returning the default page.

In summary, you now have Git installed and a basic HTML page has been cloned via Git onto your new virtual host. There are still no manual SSH commands required. If you're only after a basic HTML website, and it's in a public Git repository, then you are done!


Conclusion

We have just created an Ansible Playbook to automate the entire process of configuring your host to run the Apache Web Server, with virtual hosts, and a Git repository. All of that has been achieved without needing to log directly into the server, and the best part is that you can run your new Playbook against most Ubuntu servers to achieve the same result.

Note: if your host already has Apache set up and modified, you will most likely need to handle each of the modifications to bring it back to the required state. On the positive side, Ansible will only fix these modifications if they exist, so it's safe to have them in the main Playbook!

Ansible is incredibly powerful and also has a very easy learning curve. You can start off using the basic concepts covered in this tutorial and either stay at this level or learn a lot more to get to the really complicated parts. Either way, you will be able to configure and manage your server(s) without needing to manually login for most, if not all, tasks.




Title: how-to-deploy-a-basic-php-application-using-ansible-on-ubuntu-14-04
===
Source: https://www.digitalocean.com/community/tutorials/how-to-deploy-a-basic-php-application-using-ansible-on-ubuntu-14-04

Added: Sun Dec  4 11:41:51 CET 2016
Created: PostedApril 14, 2015 


Tutorial Series
This tutorial is part 1 of 3 in the series: Automating Your PHP Application Deployment Process with Ansible 


Introduction
+++

This tutorial covers the process of provisioning a basic PHP application using Ansible. The goal at the end of this tutorial is to have your new web server serving a basic PHP application without a single SSH connection or manual command run on the target Droplet.

We will be using the Laravel framework as an example PHP application, but these instructions can be easily modified to support other frameworks and applications if you already have your own.


Prerequisites
+++

For this tutorial, we will be using Ansible to install and configure Nginx, PHP, and other services on a Ubuntu 14.04 Droplet. This tutorial builds on basic Ansible knowledge, so if you are new to Ansible, you can read through this basic Ansible tutorial first.

To follow this tutorial, you will need:

    - One Ubuntu 14.04 Droplet of any size that we will be using to configure and deploy our PHP applicaton onto. The IP address of this machine will be referred to as your_server_ip throughout the tutorial.

    - One Ubuntu 14.04 Droplet which will be used for Ansible. This is the Droplet you will be logged into for the entirety of this tutorial.

    - Sudo non-root users configured for both Droplets.

    - SSH keys for the Ansible Droplet to authorize login on the PHP deployment Droplet, which you can set up by following this tutorial on your Ansible Droplet.



Step 1  Installing Ansible
+++

The first step is to install Ansible. This is easily accomplished by installing the PPA (Personal Package Archive), and installing the Ansible package with apt.

First, add the PPA using the apt-add-repository command.


		#
    	sudo apt-add-repository ppa:ansible/ansible

Once that has finished, update the apt cache.


		#
		sudo apt-get update

Finally, install Ansible.


		#
		sudo apt-get install ansible

MY_NOTE:
I just install ansible from the default ubuntu repos, without adding the additional PPA. Probably the version in the default ubuntu repos is older then the one available through the PPA, but I didn't have any issues related to that as of yet, so I'll stick with the Ubuntu default repos for now.

Once Ansible is installed, we'll create a new directory to work in and set up a basic configuration. By default, Ansible uses a hosts file located at /etc/ansible/hosts, which contains all of the servers it is managing. While that file is fine for some use cases, it's global, which isn't what we want here.

/etc/ansible/hosts
---

For this tutorial, we will create a local hosts file and use that instead. We can do this by creating a new Ansible configuration file within our working directory, which we can use to tell Ansible to look for a hosts file within the same directory.

Create a new directory (which we will use for the rest of this tutorial).


		#
		mkdir ~/ansible-php

Move into the new directory.


		#
		cd ~/ansible-php/



Create a new file called ansible.cfg and open it for editing using nano or your favorite text editor.


		#
		nano ansible.cfg


Add in the hostfile configuration option with the value of hosts in the [defaults] group by copying the following into the ansible.cfg file.


		#
		[defaults]
		hostfile = hosts


Save and close the ansible.cfg file. Next, we'll create the hosts file, which will contain the IP address of the PHP Droplet where we will deploy our application.


		#
		nano hosts


Copy the below to add in a section for php, replacing your_server_ip with your server IP address and sammy with the sudo non-root user you created in the prerequisites on your PHP Droplet.
hosts


		#
		[php]
		your_server_ip ansible_ssh_user=sammy


Save and close the hosts file. Let's run a simple check to make sure Ansible is able to connect to the host as expected by calling the ping module on the new php group.


$ ansible php -m ping
---

You may get an SSH host authentication check, depending on if you've ever logged into that host before. The ping should come back with a successful response, which looks something like this:


		#
		111.111.111.111 | success >> {
			"changed": false,
			"ping": "pong"
		}



Ansible is now be installed and configured; we can move on to setting up our web server.



Step 2  Installing Required Packages
+++

In this step we will install some required system packages using Ansible and apt. In particular, we will install git, nginx, sqlite3, mcrypt, and a couple of php5-* packages.


Before we add in the apt module to install the packages we want, we need to create a basic playbook. We'll build on this playbook as we go through the tutorial. Create a new playbook called php.yml.


		#
		nano php.yml


Paste in the following configuration. The first two lines specifies the hosts group we wish to use (php) and makes sure it runs commands with sudo by default. The rest adds in a module with the packages that we need. You can customize this for your own application, or use the configuration below if you're following along with the example Laravel application.


		#
		#
		---
		- hosts: php
		  sudo: yes

		  tasks:

		  - name: install packages
			apt: name={{ item }} update_cache=yes state=latest
			with_items:
			  - git
			  - mcrypt
			  - nginx
			  - php5-cli
			  - php5-curl
			  - php5-fpm
			  - php5-intl
			  - php5-json
			  - php5-mcrypt
			  - php5-sqlite
			  - sqlite3


Save the php.yml file. Finally, run ansible-playbook to install the packages on the Droplet. Don't forget to use the --ask-sudo-pass option if your sudo user on your PHP Droplet requires a password.


$ ansible-playbook php.yml --ask-sudo-pass
---


Step 3  Modifying System Configuration Files
+++


In this section we will modify some of the system configuration files on the PHP Droplet. The most important configuration option to change (aside from Nginx's files, which will be covered in a later step) is the cgi.fix_pathinfo option in php5-fpm, because the default value is a security risk.

We'll first explain all the sections we're going to add to this file, then include the entire php.yml file for you to copy and paste in.

The lineinfile module can be used to ensure the configuration value within the file is exactly as we expect it. This can be done using a generic regular expression so Ansible can understand most forms the parameter is likely to be in. We'll also need to restart php5-fpm and nginx to ensure the change takes effect, so we need to add in two handlers as well, in a new handlers section. Handlers are perfect for this, as they are only fired when the task changes. They also run at the end of the playbook, so multiple tasks can call the same handler and it will only run once.

The section to do the above will look like this:


		#
		#
		- name: ensure php5-fpm cgi.fix_pathinfo=0
		  lineinfile: dest=/etc/php5/fpm/php.ini regexp='^(.*)cgi.fix_pathinfo=' line=cgi.fix_pathinfo=0
		  notify:
		    - restart php5-fpm
		    - restart nginx

		  handlers:
		    - name: restart php5-fpm
		      service: name=php5-fpm state=restarted

		    - name: restart nginx
		      service: name=nginx state=restarted


Note: Ansible version 1.9.1 bug

 There is a bug with Ansible version 1.9.1 that prevents php5-fpm from being restarted with the service module, as we have used in our handlers.

Until a fix is released, you can work around this issue by changing the restart php5-fpm handler from using the service command to using the shell command, like this:


		#
		- name: restart php5-fpm
		  shell: service php5-fpm restart

This will bypass the issue and correctly restart php5-fpm.


Next, we also need to ensure the php5-mcrypt module is enabled. This is done by running the php5enmod script with the shell task, and checking the 20-mcrypt.ini file is in the right place when it's enabled. Note that we are telling Ansible that the task creates a specific file. If that file exists, the task won't be run.


		#
		- name: enable php5 mcrypt module
		  shell: php5enmod mcrypt
		  args:
			creates: /etc/php5/cli/conf.d/20-mcrypt.ini


Now, open php.yml for editing again.


Add the above tasks and handlers, so the file matches the below:


		#
		#
		---
		- hosts: php
		  sudo: yes

		  tasks:

		  - name: install packages
			apt: name={{ item }} update_cache=yes state=latest
			with_items:
			  - git
			  - mcrypt
			  - nginx
			  - php5-cli
			  - php5-curl
			  - php5-fpm
			  - php5-intl
			  - php5-json
			  - php5-mcrypt
			  - php5-sqlite
			  - sqlite3

		  - name: ensure php5-fpm cgi.fix_pathinfo=0
			lineinfile: dest=/etc/php5/fpm/php.ini regexp='^(.*)cgi.fix_pathinfo=' line=cgi.fix_pathinfo=0
			notify:
			  - restart php5-fpm
			  - restart nginx

		  - name: enable php5 mcrypt module
			shell: php5enmod mcrypt
			args:
			  creates: /etc/php5/cli/conf.d/20-mcrypt.ini

		  handlers:
			- name: restart php5-fpm
			  service: name=php5-fpm state=restarted

			- name: restart nginx
			  service: name=nginx state=restarted


Finally, run the playbook.

$ ansible-playbook php.yml --ask-sudo-pass
---


The Droplet now has all the required packages installed and the basic configuration set up and ready to go.


Step 4  Cloning the Git Repository
+++

In this section we will clone the Laravel framework repository onto our Droplet using Git. Like in Step 3, we'll explain all the sections we're going to add to the playbook, then include the entire php.yml file for you to copy and paste in.

Before we clone our Git repository, we need to make sure /var/www exists. We can do this by creating a task with the file module.


		#
		- name: create /var/www/ directory
		  file: dest=/var/www/ state=directory owner=www-data group=www-data mode=0700


As mentioned above, we need to use the Git module to clone the repository onto our Droplet. The process is simple because all we normally require for a git clone command is the source repository. In this case, we will also define the destination, and tell Ansible to not update the repository if it already exists by setting update=no. Because we are using Laravel, the git repository URL we will use is https://github.com/laravel/laravel.git.


However, we need to run the task as the www-data user to ensure that the permissions are correct. To do this, we can tell Ansible to run the command as a specific user using sudo. The final task will look like this:


		#
		- name: Clone git repository
		  git: >
			dest=/var/www/laravel
			repo=https://github.com/laravel/laravel.git
			update=no
		  sudo: yes
		  sudo_user: www-data


Note: For SSH-based repositories you can add accept_hostkey=yes to prevent SSH host verification from hanging the task.

As before, open the php.yml file for editing.


Add the above tasks to the the playbook; the end of the file should match the following:



		#
		#
		...

		  - name: enable php5 mcrypt module
			shell: php5enmod mcrypt
			args:
			  creates: /etc/php5/cli/conf.d/20-mcrypt.ini

		  - name: create /var/www/ directory
			file: dest=/var/www/ state=directory owner=www-data group=www-data mode=0700

		  - name: Clone git repository
			git: >
			  dest=/var/www/laravel
			  repo=https://github.com/laravel/laravel.git
			  update=no
			sudo: yes
			sudo_user: www-data

		  handlers:
			- name: restart php5-fpm
			  service: name=php5-fpm state=restarted

			- name: restart nginx
			  service: name=nginx state=restarted


Save and close the playbook, then run it.

MY_NOTE:
I have used "become_user" instead of "sudo_user", when cloning git repository since "sudo_user" is deprecated.


Step 5  Creating an Application with Composer
+++


In this step, we will use Composer to install the PHP application and its dependencies.

Composer has a create-project command that installs all of the required dependencies and then runs the project creation steps defined in the post-create-project-cmd section of the composer.json file. This is the best way to ensure the application is set up correctly for its first use.

We can use the following Ansible task to download and install Composer globally as /usr/local/bin/composer. It will then be accessible by anyone using the Droplet, including Ansible.


		#
		- name: install composer
		  shell: curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
		  args:
			creates: /usr/local/bin/composer



With Composer installed, there is a Composer module that we can use. In our case, we want to tell Composer where our project is (using the working_dir paramter), and to run the create-project command. We also need to add optimize_autoloader=no parameter, as this flag isn't supported by the create-project command. Like the git command, we also want to run this as the www-data user to ensure permissions are valid. Putting it all together, we get this task:


		#
		- name: composer create-project
		  composer: command=create-project working_dir=/var/www/laravel optimize_autoloader=no
		  sudo: yes
		  sudo_user: www-data


Note: create-project task may take a significant amount of time on a fresh Droplet, as Composer will have an empty cache and will need download everything fresh.

Now, open the php.yml file for editing.


Add the tasks above at the end of the tasks section, above handlers, so that the end of the playbook matches the following:


		#
		#
		...
		  - name: Clone git repository
			git: >
			  dest=/var/www/laravel
			  repo=https://github.com/laravel/laravel.git
			  update=no
			sudo: yes
			sudo_user: www-data

		  - name: install composer
			shell: curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
			args:
			  creates: /usr/local/bin/composer

		  - name: composer create-project
			composer: command=create-project working_dir=/var/www/laravel optimize_autoloader=no
			sudo: yes
			sudo_user: www-data

		  handlers:
			- name: restart php5-fpm
			  service: name=php5-fpm state=restarted

			- name: restart nginx
			  service: name=nginx state=restarted


Finally, run the playbook.


What would happen if we ran Ansible again now? The composer create-project would run again, and in the case of Laravel, this means a new APP_KEY. So what we want instead is to set that task to only run after a fresh clone. We can ensure that it is only run once by registering a variable with the results of the git clone task, and then checking those results within the composer create-project task. If the git clone task was Changed, then we run composer create-project, if not, it is skipped.

Note: There appears to be a bug in some versions of the Ansible composer module, and it may output OK instead of Changed, as it ignores that scripts were executed even though no dependencies were installed.

Open the php.yml file for editing.

Find the git clone task. Add the register option to save the results of the task into the the cloned variable, like this:


		#
		#
		- name: Clone git repository
		  git: >
			dest=/var/www/laravel
			repo=https://github.com/laravel/laravel.git
			update=no
		  sudo: yes
		  sudo_user: www-data
		  register: cloned


Next, find the composer create-project task. Add the when option to check the cloned variable to see if it has changed or not.


		#
		- name: composer create-project
		  composer: command=create-project working_dir=/var/www/laravel optimize_autoloader=no
		  sudo: yes
		  sudo_user: www-data
		  when: cloned|changed



Save the playbook, and run it.

Now Composer will stop changing the APP_KEY each time it is run.


Step 6  Updating Environment Variables
+++


In this step, we will update the environment variables for our application.

Laravel comes with a default .env file which sets the APP_ENV to local and APP_DEBUG to true. We want to swap them for production and false, respectively. This can be done simply using the lineinfile module with the following tasks.


Open the php.yml file for editing.


Add this task to the the playbook; the end of the file should match the following:


		#
		#
		...

		  - name: composer create-project
			composer: command=create-project working_dir=/var/www/laravel optimize_autoloader=no
			sudo: yes
			sudo_user: www-data
			when: cloned|changed

		  - name: set APP_DEBUG=false
			lineinfile: dest=/var/www/laravel/.env regexp='^APP_DEBUG=' line=APP_DEBUG=false

		  - name: set APP_ENV=production
			lineinfile: dest=/var/www/laravel/.env regexp='^APP_ENV=' line=APP_ENV=production

		  handlers:
			- name: restart php5-fpm
			  service: name=php5-fpm state=restarted

			- name: restart nginx
			  service: name=nginx state=restarted


Save and run the playbook.

The lineinfile module is very useful for quick tweaks of any text file, and it's great for ensuring environment variables like this are set correctly.


Step 7 Configuring Nginx
+++

In this section we will configure a Nginx to serve the PHP application.

If you visit your Droplet in your web browser now (i.e. http://your_server_ip/), you will see the Nginx default page instead of the Laravel new project page. This is because we still need to configure our Nginx web server to serve the application from the /var/www/laravel/public directory. To do this we need to update our Nginx default configuration with that directory, and add in support for php-fpm, so it can handle PHP scripts.

Create a new file called nginx.conf:


		#
		nano nginx.conf




Save this server block within that file. You can check out Step 4 of this tutorial for more details about this Nginx configuration; the modifications below are specifying where the Laravel public directory is and making sure Nginx uses the hostname we've defined in the hosts file as the server_name with the inventory_hostname variable.


		#
		#
		server {
			listen 80 default_server;
			listen [::]:80 default_server ipv6only=on;

			root /var/www/laravel/public;
			index index.php index.html index.htm;

			server_name {{ inventory_hostname }};

			location / {
				try_files $uri $uri/ =404;
			}

			error_page 404 /404.html;
			error_page 500 502 503 504 /50x.html;
			location = /50x.html {
				root /var/www/laravel/public;
			}

			location ~ \.php$ {
				try_files $uri =404;
				fastcgi_split_path_info ^(.+\.php)(/.+)$;
				fastcgi_pass unix:/var/run/php5-fpm.sock;
				fastcgi_index index.php;
				fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
				include fastcgi_params;
			}
		}



Save and close the nginx.conf file.

Now, we can use the template module to push our new configuration file across. The template module may look and sound very similar to the copy module, but there is a big difference. copy will copy one or more files across without making any changes, while template copies a single files and will resolve all variables within the the file. Because we have used {{ inventory_hostname }} within our config file, we use the template module so it is resolved into the IP address that we used in the hosts file. This way, we don't need to hard code the configuration files that Ansible uses.


However, as is usual when writing tasks, we need to consider the what will happen on the Droplet. Because we are changing the Nginx configuration, we need to restart Nginx and php-fpm. This is done using the notify options.


		#
		#
		- name: Configure nginx
		  template: src=nginx.conf dest=/etc/nginx/sites-available/default
		  notify:
			- restart php5-fpm
			- restart nginx


Open your php.yml file.

Add in this nginx task at the end of the tasks section. The entire php.yml file should now look like this.


		#
		#
		---
		- hosts: php
		  sudo: yes

		  tasks:

		  - name: install packages
			apt: name={{ item }} update_cache=yes state=latest
			with_items:
			  - git
			  - mcrypt
			  - nginx
			  - php5-cli
			  - php5-curl
			  - php5-fpm
			  - php5-intl
			  - php5-json
			  - php5-mcrypt
			  - php5-sqlite
			  - sqlite3

		  - name: ensure php5-fpm cgi.fix_pathinfo=0
			lineinfile: dest=/etc/php5/fpm/php.ini regexp='^(.*)cgi.fix_pathinfo=' line=cgi.fix_pathinfo=0
			notify:
			  - restart php5-fpm
			  - restart nginx

		  - name: enable php5 mcrypt module
			shell: php5enmod mcrypt
			args:
			  creates: /etc/php5/cli/conf.d/20-mcrypt.ini

		  - name: create /var/www/ directory
			file: dest=/var/www/ state=directory owner=www-data group=www-data mode=0700

		  - name: Clone git repository
			git: >
			  dest=/var/www/laravel
			  repo=https://github.com/laravel/laravel.git
			  update=no
			sudo: yes
			sudo_user: www-data
			register: cloned

		  - name: install composer
			shell: curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
			args:
			  creates: /usr/local/bin/composer

		  - name: composer create-project
			composer: command=create-project working_dir=/var/www/laravel optimize_autoloader=no
			sudo: yes
			sudo_user: www-data
			when: cloned|changed

		  - name: set APP_DEBUG=false
			lineinfile: dest=/var/www/laravel/.env regexp='^APP_DEBUG=' line=APP_DEBUG=false

		  - name: set APP_ENV=production
			lineinfile: dest=/var/www/laravel/.env regexp='^APP_ENV=' line=APP_ENV=production

		  - name: Configure nginx
			template: src=nginx.conf dest=/etc/nginx/sites-available/default
			notify:
			  - restart php5-fpm
			  - restart nginx

		  handlers:
			- name: restart php5-fpm
			  service: name=php5-fpm state=restarted

			- name: restart nginx
			  service: name=nginx state=restarted


Save and run the playbook again.


Once it completes, go back to your browser and refresh. You should now see the Laravel new project page!


Conclusion
+++

This tutorial covers deploying a PHP application with a public repository. While it is perfect for learning how Ansible works, you won't always be working on fully open source projects with open repositories. This means that you will need to authenticate the git clone in Step 3 with your private repository. This can be very easily done using SSH keys.

For example, once you have your SSH deploy keys created and set on your repository, you can use Ansible to copy and configure them on your server before the git clone task:


		#
		- name: create /var/www/.ssh/ directory
		  file: dest=/var/www/.ssh/ state=directory owner=www-data group=www-data mode=0700

		- name: copy private ssh key
		  copy: src=deploykey_rsa dest=/var/www/.ssh/id_rsa owner=www-data group=www-data mode=0600


That should allow the server to correctly authenticate and deploy your application.

You have just deployed a basic PHP application on a Ubuntu-based Nginx web server using Composer to manage dependencies! All of it has been completed without a needing to log directly into your PHP Droplet and run a single manual command.





Title: how-to-deploy-an-advanced-php-application-using-ansible-on-ubuntu-14-04
===
Source: https://www.digitalocean.com/community/tutorials/how-to-deploy-an-advanced-php-application-using-ansible-on-ubuntu-14-04

Added: Mon Dec  5 10:39:34 CET 2016
Created: PostedJune 2, 2015 



Tutorial Series
This tutorial is part 2 of 3 in the series: Automating Your PHP Application Deployment Process with Ansible 


Introduction
+++

This tutorial is the second in a series about deploying PHP applications using Ansible on Ubuntu 14.04. The first tutorial covers the basic steps for deploying an application, and is a starting point for the steps outlined in this tutorial.


In this tutorial we will cover setting up SSH keys to support code deployment/publishing tools, configuring the system firewall, provisioning and configuring the database (including the password!), and setting up task schedulers (crons) and queue daemons. The goal at the end of this tutorial is for you to have a fully working PHP application server with the aforementioned advanced configuration.


Like the last tutorial, we will be using the Laravel framework as our example PHP application. However, these instructions can be easily modified to support other frameworks and applications if you already have your own.

Prerequisites
+++

This tutorial follows on directly from the end of the first tutorial in the series, and all of the configuration and files generated for that tutorial are required. If you haven't completed that tutorial yet, please do so first before continuing with this tutorial.


Step 1  Switching the Application Repository
+++

In this step, we will update the Git repository to a slightly customized example repository.

Because the default Laravel installation doesn't require the advanced features that we will be setting up in this tutorial, we will be switching the existing repository from the standard repository to an example repository with some debugging code added, just to show when things are working. The repository we will use is located at https://github.com/do-community/do-ansible-adv-php.

If you haven't done so already, change directories into ansible-php from the previous tutorial.


		#
		cd ~/ansible-php/

Open up our existing playbook for editing.


		#
        nano php.yml


Find and update the "Clone git repository" task, so it looks like this.


		#
		- name: Clone git repository
		  git: >
			dest=/var/www/laravel
			repo=https://github.com/do-community/do-ansible-adv-php
			update=yes
			version=example
		  sudo: yes
		  sudo_user: www-data
		  register: cloned


Save and run the playbook.

$ ansible-playbook php.yml --ask-sudo-pass
---


When it has finished running, visit your server in your web browser (i.e. http://your_server_ip/). You should see a message that says "could not find driver".

This means we have successfully swapped out the default repository for our example repository, but the application cannot connect to the database. This is what we expect to see here, and we will install and set up the database later in the tutorial.


Step 2  Setting up SSH Keys for Deployment
+++


In this step, we will set up SSH keys that can be used for application code deployment scripts.

While Ansible is great for maintaining configuration and setting up servers and applications, tools like Envoy and Rocketeer are often used to push code changes onto your server and run application commands remotely. Most of these tools require an SSH connection that can access the application installation directly. In our case, this means we need to configure SSH keys for the www-data user.


MY_NOTE:
I skipped this part of the tutorial.


We will need the public key file for the user you wish to push your code from. This file is typically found at ~/.ssh/id_rsa.pub. Copy that file into the ansible-php directory.


		#
		cp ~/.ssh/id_rsa.pub ~/ansible-php/deploykey.pub



We can use the Ansible authorized_key module to install our public key within /var/www/.ssh/authorized_keys, which will allow the deployment tools to connect and access our application. The configuration only needs to know where the key is, using a lookup, and the user the key needs to be installed for (www-data in our case).


		#
		- name: Copy public key into /var/www
		  authorized_key: user=www-data key="{{ lookup('file', 'deploykey.pub') }}"



We also need to set the www-data user's shell, so we can actually log in. Otherwise, SSH will allow the connection, but there will be no shell presented to the user. This can be done using the user module, and setting the shell to /bin/bash (or your preferred shell).


		#
		- name: Set www-data user shell
		  user: name=www-data shell=/bin/bash



Now, open up the playbook for editing to add in the new tasks.


Add the above tasks to your php.yml playbook; the end of the file should match the following. The additions are highlighted in red.


		#
		. . .

		  - name: Configure nginx
			template: src=nginx.conf dest=/etc/nginx/sites-available/default
			notify:
			  - restart php5-fpm
			  - restart nginx

		  - name: Copy public key into /var/www
			authorized_key: user=www-data key="{{ lookup('file', 'deploykey.pub') }}"

		  - name: Set www-data user shell
			user: name=www-data shell=/bin/bash

		  handlers:

		. . .



Save and run the playbook.


		#
		ansible-playbook php.yml --ask-sudo-pass

When Ansible finishes, you should be able to SSH in using the www-data user.


		#
		ssh www-data@your_server_ip

If you successfully log in, it's working! You can now log back out by entering logout or pressing CTRL+D.

We won't need to use that connection for any other steps in this tutorial, but it will be useful if you are setting up other tools, as mentioned above, or for general debugging and application maintenance as required.



Step 3  Configuring the Firewall
+++

In this step we will configure the firewall on the server to allow only connections for HTTP and SSH.

Ubuntu 14.04 comes with UFW (Uncomplicated Firewall) installed by default, and Ansible supports it with the ufw module. It has a number of powerful features and has been designed to be as simple as possible. It's perfectly suited for self-contained web servers that only need a couple of ports open. In our case, we want port 80 (HTTP) and port 22 (SSH) open. You may also want port 443 for HTTPS.


The ufw module has a number of different options which perform different tasks. The different tasks we need to perform are:

    - Enable UFW and deny all incoming traffic by default.
    - Open the SSH port but rate limit it to prevent brute force attacks.
    - Open the HTTP port.

This can be done with the following tasks, respectively.


		#
		- name: Enable UFW
		  ufw: direction=incoming policy=deny state=enabled

		- name: UFW limit SSH
		  ufw: rule=limit port=ssh

		- name: UFW open HTTP
		  ufw: rule=allow port=http



As before, open the php.yml file for editing.

Add the above tasks to the the playbook; the end of the file should match the following.


		#
		. . .

		  - name: Copy public key into /var/www
			authorized_key: user=www-data key="{{ lookup('file', 'deploykey.pub') }}"

		  - name: Set www-data user shell
			user: name=www-data shell=/bin/bash

		  - name: Enable UFW
			ufw: direction=incoming policy=deny state=enabled

		  - name: UFW limit SSH
			ufw: rule=limit port=ssh

		  - name: UFW open HTTP
			ufw: rule=allow port=http

		  handlers:

		. . .


Save and run the playbook.

When that has successfully completed, you should still be able to connect via SSH (using Ansible) or HTTP to your server; other ports will now be blocked.

You can verify the status of UFW at any time by running this command:


$ ansible php --sudo --ask-sudo-pass -m shell -a "ufw status verbose"
---


Breaking down the Ansible command above:

    - ansible: Run a raw Ansible task, without a playbook.
    - php: Run the task against the hosts in this group.
    - "--sudo": Run the command as sudo.
    - "--ask-sudo-pass": Prompt for the sudo password.
    - "-m shell": Run the shell module.
    - "-a "ufw status verbose"": The options to be passed into the module. Because it is a shell command, we pass the raw command (i.e. ufw status verbose) straight in without any key=value options.

It should return something like this.


		#
		your_server_ip | success | rc=0 >>
		Status: active
		Logging: on (low)
		Default: deny (incoming), allow (outgoing), disabled (routed)
		New profiles: skip

		To                         Action      From
		--                         ------      ----
		22                         LIMIT IN    Anywhere
		80                         ALLOW IN    Anywhere
		22 (v6)                    LIMIT IN    Anywhere (v6)
		80 (v6)                    ALLOW IN    Anywhere (v6)


Step 4  Installing the MySQL Packages
+++

In this step we will set up a MySQL database for our application to use.

The first step is to ensure that MySQL is installed on our server by simply adding the required packages to the install packages task at the top of our playbook. The packages we need are mysql-server, mysql-client, and php5-mysql. We will also need python-mysqldb so Ansible can communicate with MySQL.

As we are adding packages, we need to restart nginx and php5-fpm to ensure the new packages are usable by the application. In this case, we need MySQL to be available to PHP, so it can connect to the database.

One of the fantastic things about Ansible is that you can modify any of the tasks and re-run your playbook and the changes will be applied. This includes lists of options, like we have with the apt task.

As before, open the php.yml file for editing.


Find the install packages task, and update it to include the packages above:


		#
		. . .
		- name: install packages
		  apt: name={{ item }} update_cache=yes state=latest
		  with_items:
			- git
			- mcrypt
			- nginx
			- php5-cli
			- php5-curl
			- php5-fpm
			- php5-intl
			- php5-json
			- php5-mcrypt
			- php5-sqlite
			- sqlite3
			- mysql-server
			- mysql-client
			- php5-mysql
			- python-mysqldb
		  notify:
			- restart php5-fpm
			- restart nginx
		. . .


Save and run the playbook.


Step 5  Setting up the MySQL Database
+++

In this step we will create a MySQL database for our application.

Ansible can talk directly to MySQL using the mysql_-prefaced modules (e.g. mysql_db, mysql_user). The mysql_db module provides a way to ensure a database with a specific name exists, so we can use a task like this to create the database.


		#
		- name: Create MySQL DB
		  mysql_db: name=laravel state=present


We also need a valid user account with a known password to allow our application to connect to the database. One approach to this is to generate a password locally and save it in our Ansible playbook, but that is insecure and there is a better way.

We will generate the password using Ansible on the server itself and use it directly where it is needed. To generate a password, we will use the makepasswd command line tool, and ask for a 32-character password. Because makepasswd isn't default on Ubuntu, we will need to add that to the packages list too.


We will also tell Ansible to remember the output of the command (i.e. the password), so we can use it later in our playbook. However, because Ansible doesn't know if it has already run a shell command, we'll also create a file when we run that command. Ansible will check if the file exists, and if so, it will assume the command has already been run and won't run it again.


The task looks like this:


		#
		- name: Generate DB password
		  shell: makepasswd --chars=32
		  args:
			creates: /var/www/laravel/.dbpw
		  register: dbpwd



Next, we need to create the actual MySQL database user with the password we specified. This is done using the mysql_user module, and we can use the stdout option on the variable we defined during the password generation task to get the raw output of the shell command, like this: dbpwd.stdout.


The mysql_user command accepts the name of the user and the privileges required. In our case, we want to create a user called laravel and give them full privileges on the laravel table. We also need to tell the task to only run when the dbpwd variable has changed, which will only be when the password generation task is run.

The task should look like this:


		#
		- name: Create MySQL User
		  mysql_user: name=laravel password={{ dbpwd.stdout }} priv=laravel.*:ALL state=present
		  when: dbpwd.changed


Putting this together, open the php.yml file for editing, so we can add in the above tasks.


Firstly, find the install packages task, and update it to include the makepasswd package.


		#
		. . .

		- name: install packages
		  apt: name={{ item }} update_cache=yes state=latest
		  with_items:
			- git
			- mcrypt
			- nginx
			- php5-cli
			- php5-curl
			- php5-fpm
			- php5-intl
			- php5-json
			- php5-mcrypt
			- php5-sqlite
			- sqlite3
			- mysql-server
			- mysql-client
			- php5-mysql
			- python-mysqldb
			- makepasswd
		  notify:
			- restart php5-fpm
			- restart nginx

		. . .


Then, add the password generation, MySQL database creation, and user creation tasks at the bottom.


		#
		. . .

		  - name: UFW limit SSH
			ufw: rule=limit port=ssh

		  - name: UFW open HTTP
			ufw: rule=allow port=http

		  - name: Create MySQL DB
			mysql_db: name=laravel state=present

		  - name: Generate DB password
			shell: makepasswd --chars=32
			args:
			  creates: /var/www/laravel/.dbpw
			register: dbpwd

		  - name: Create MySQL User
			mysql_user: name=laravel password={{ dbpwd.stdout }} priv=laravel.*:ALL state=present
			when: dbpwd.changed

		  handlers:

		. . .



Do not run the playbook yet! You may have noticed that although we have created the MySQL user and database, we haven't done anything with the password. We will cover that in the next step. When using shell tasks within Ansible, it is always important to remember to complete the entire workflow that deals with the output/results of the task before running it to avoid having to manually log in and reset the state.


Step 6  Configuring the PHP Application for the Database
+++


In this step, we will save the MySQL database password into the .env file for the application.

Like we did in the last tutorial, we will update the .env file to include our newly created database credentials. By default Laravel's .env file contains these lines:


		#
		DB_HOST=localhost
		DB_DATABASE=homestead
		DB_USERNAME=homestead
		DB_PASSWORD=secret



We can leave the DB_HOST line as-is, but will update the other three using the following tasks, which are very similar to the tasks we used in the previous tutorial to set APP_ENV and APP_DEBUG.


		#
		- name: set DB_DATABASE
		  lineinfile: dest=/var/www/laravel/.env regexp='^DB_DATABASE=' line=DB_DATABASE=laravel

		- name: set DB_USERNAME
		  lineinfile: dest=/var/www/laravel/.env regexp='^DB_USERNAME=' line=DB_USERNAME=laravel

		- name: set DB_PASSWORD
		  lineinfile: dest=/var/www/laravel/.env regexp='^DB_PASSWORD=' line=DB_PASSWORD={{ dbpwd.stdout }}
		  when: dbpwd.changed


As we did with the MySQL user creation task, we have used the generated password variable (dbpwd.stdout) to populate the file with the password, and have added the when option to ensure it is only run when dbpwd has changed.


Now, because the .env file already existed before we added our password generation task, we will need to save the password to another file. The generation task can look for that file's existence (which we already set up within the task). We will also use the sudo and sudo_user options to tell Ansible to create the file as the www-data user.


		#
		- name: Save dbpw file
		  lineinfile: dest=/var/www/laravel/.dbpw line="{{ dbpwd.stdout }}" create=yes state=present
		  sudo: yes
		  sudo_user: www-data
		  when: dbpwd.changed


Open the php.yml file for editing.


Add the above tasks to the the playbook; the end of the file should match the following.


		#
		. . .

		  - name: Create MySQL User
			mysql_user: name=laravel password={{ dbpwd.stdout }} priv=laravel.*:ALL state=present
			when: dbpwd.changed

		  - name: set DB_DATABASE
			lineinfile: dest=/var/www/laravel/.env regexp='^DB_DATABASE=' line=DB_DATABASE=laravel

		  - name: set DB_USERNAME
			lineinfile: dest=/var/www/laravel/.env regexp='^DB_USERNAME=' line=DB_USERNAME=laravel

		  - name: set DB_PASSWORD
			lineinfile: dest=/var/www/laravel/.env regexp='^DB_PASSWORD=' line=DB_PASSWORD={{ dbpwd.stdout }}
			when: dbpwd.changed

		  - name: Save dbpw file
			lineinfile: dest=/var/www/laravel/.dbpw line="{{ dbpwd.stdout }}" create=yes state=present
			sudo: yes
			sudo_user: www-data
			when: dbpwd.changed

		  handlers:

		. . .



Again, do not run the playbook yet! We have one more step to complete before we can run the playbook.


Step 7  Migrating the Database
+++


In this step, we will run the database migrations to set up the database tables.

In Laravel, this is done by running the migrate command (i.e. php artisan migrate --force) within the Laravel directory. Note that we have added the --force flag because the production environment requires it.

The Ansible task to perform this looks like this.


		#
		  - name: Run artisan migrate
			shell: php /var/www/laravel/artisan migrate --force
			sudo: yes
			sudo_user: www-data
			when: dbpwd.changed



Now it is time to update our playbook. Open the php.yml file for editing.


Add the above tasks to the the playbook; the end of the file should match the following.


		#
		. . .

		  - name: Save dbpw file
			lineinfile: dest=/var/www/laravel/.dbpw line="{{ dbpwd.stdout }}" create=yes   state=present
			sudo: yes
			sudo_user: www-data
			when: dbpwd.changed

		  - name: Run artisan migrate
			shell: php /var/www/laravel/artisan migrate --force
			sudo: yes
			sudo_user: www-data
			when: dbpwd.changed

		  handlers:

		. . .



Finally, we can save and run the playbook.


When that finishes executing, refresh the page in your browser and you should see a message that says:


		#
		Queue: NO
		Cron: NO



This means the database is set up correctly and working as expected, but we haven't yet set up cron tasks or the queue daemon.


Step 8  Configuring cron Tasks
+++

In this step, we will set up any cron tasks that need to be configured.

Cron tasks are commands that run on a set schedule and can be used to perform any number of tasks for your application, like performing maintenance tasks or sending out email activity updates  essentially anything that needs to be done periodically without manual user intervention. Cron tasks can run as frequently as every minute, or as infrequently as you require.


Laravel comes with an Artisan command called schedule:run by default, which is designed to be run every minute and executes the defined scheduled tasks within the application. This means we only need to add a single cron task, if our application takes advantage of this feature.

Ansible has a cron module with a number of different options that translate directly into the different options you can configure via cron:



    - job: The command to execute. Required if state=present.
    - minute, hour, day, month, and weekday: The minute, hour, day, month, or day of the week when the job should run, respectively.
    - special_time (reboot, yearly, annually, monthly, weekly, daily, hourly): Special time specification nickname.


By default, it will create a task that runs every minute, which is what we want. This means the task we want looks like this:


		#
		- name: Laravel Scheduler
		  cron: >
			job="run-one php /var/www/laravel/artisan schedule:run 1>> /dev/null 2>&1"
			state=present
			user=www-data
			name="php artisan schedule:run"



The run-one command is a small helper in Ubuntu that ensures the command is only being run once. This means that if a previous schedule:run command is still running, it won't be run again. This is helpful to avoid a situation where a cron task becomes locked in a loop, and over time, more and more instances of the same task are started until the server runs out of resources.

As before, open the php.yml file for editing.


Add the above task to the the playbook; the end of the file should match the following.


		#
		. . .

		  - name: Run artisan migrate
			shell: php /var/www/laravel/artisan migrate --force
			sudo: yes
			sudo_user: www-data
			when: dbpwd.changed

		  - name: Laravel Scheduler
			cron: >
			  job="run-one php /var/www/laravel/artisan schedule:run 1>> /dev/null 2>&1"
			  state=present
			  user=www-data
			  name="php artisan schedule:run"

		  handlers:

		. . .



Save and run the playbook:


Now, refresh the page in your browser. In a minute, it will update to look like this.


		#
		Queue: NO
		Cron: YES


This means that the cron is working in the background correctly. As part of the example application, there is a cron job that is running every minute updating a status entry in the database so the application knows it is running.


Step 9  Configuring the Queue Daemon
+++

Like the schedule:run Artisan command from step 8, Laravel also comes with a queue worker that can be started with the queue:work --daemon Artisan command. In this step we will configure the queue daemon worker for Laravel.


Queue workers are similar to cron jobs in that they run tasks in the background. The difference is that the application pushes jobs into the queue, either via actions performed by the user or from tasks scheduled through a cron job. Queue tasks are executed by the worker one at a time, and will be processed on-demand when they are found in the queue. Queue tasks are commonly used for work that takes time to execute, such as sending emails or making API calls to external services.


Unlike the schedule:run command, this isn't a command that needs to be run every minute. Instead, it needs to run as a daemon in the background constantly. A common way to do this is by using a third party package like supervisord, but that method requires understanding how to configure and manage said system. There is a much simpler way to implement it using cron and the run-one command.

We will create a cron entry to start the queue worker daemon, and use run-one to run it. This means that cron will start the process the first time it runs, and any subsequent cron runs will be ignored by run-one while the worker is running. As soon as the worker stops, run-one will allow the command to run again, and the queue worker will start again. It is an incredibly simple and easy to use method that saves you from needing to learn how to configure and use another tool.

With all of that in mind, we will create another cron task to run our queue worker.


		#
		- name: Laravel Queue Worker
		  cron: >
			job="run-one php /var/www/laravel/artisan queue:work --daemon --sleep=30 --delay=60 --tries=3 1>> /dev/null 2>&1"
			state=present
			user=www-data
			name="Laravel Queue Worker"


As before, open the php.yml file for editing.

Add the above task to the the playbook; the end of the file should match the following:


		#
		. . .

		  - name: Laravel Scheduler
			cron: >
			  job="run-one php /var/www/laravel/artisan schedule:run 1>> /dev/null 2>&1"
			  state=present
			  user=www-data
			  name="php artisan schedule:run"

		  - name: Laravel Queue Worker
			cron: >
			  job="run-one php /var/www/laravel/artisan queue:work --daemon --sleep=30 --delay=60 --tries=3 1>> /dev/null 2>&1"
			  state=present
			  user=www-data
			  name="Laravel Queue Worker"

		  handlers:
		. . .



Save and run the playbook.

Like before, refresh the page in your browser. After a minute, it will update to look like this:


		#
		Queue: YES
		Cron: YES



This means that the queue worker is working in the background correctly. The cron job that we started in the last step pushes a job onto the queue. This job updates the database when it is run to show that it is working.

We now have a working example Laravel application which includes functioning cron jobs and queue workers.



Conclusion

This tutorial covered the some of the more advanced topics when using Ansible for deploying PHP applications. All of the tasks used can be easily modified to suit most PHP applications (depending on their specific requirements), and it should give you a good starting point to set up your own playbooks for your applications.

We have not used a single SSH command as part of this tutorial (apart from checking the www-data user login), and everything â€” including the MySQL user password â€” has been set up automatically. After following this tutorial, your application is ready to go and supports tools to push code updates.




Title: how-to-automate-installing-wordpress-on-ubuntu-14-04-using-ansible
===
Source: https://www.digitalocean.com/community/tutorials/how-to-automate-installing-wordpress-on-ubuntu-14-04-using-ansible

Added: Mon Dec  5 15:56:18 CET 2016
Created: PostedJune 25, 2015


Introduction
+++

Ansible is a simple, agentless way to automate your infrastructure. If you find yourself deploying WordPress over and over again, Ansible could save you a lot of time.

With a few lines of YAML (a straighforward markup language), we will automate the typically tedious process of setting up WordPress on a fresh Ubuntu 14.04 server. We will install WordPress more or less according to the process outlined in this tutorial, but automatically.

We will use two servers: A build server running Ansible, and a target server on which we will install WordPress using Ansible.  



Prerequisites
+++

In order to complete this tutorial, you will need to have the following set up:



    - A build server running Ubuntu 14.04. We will install Ansible on this server (referred to in this tutorial as the build-server). We will log into this server, and all the files and commands for this tutorial will be run on this server
    - A target server running Ubuntu 14.04. We will install WordPress (via Ansible) on this server (referred to in this tutorial as the wordpress-server)
    - Sudo non-root users configured for both servers
    - Add the SSH key of your build-server sudo user to your wordpress-server's sudo user's authorized_keys. You can set this up by following this tutorial. You should run the tutorial from your build-server and upload the key to your wordpress-server


(Optional) Passwordless sudo Access

It is faster but less secure to use passwordless sudo access on your wordpress-server.

To give our sudo user on the wordpress-server this privelege, we'll need to edit the sudoers file. Type visudo to edit the sudoers file:


		#
		$ visudo


Add this line at the end:


		#
		sammy ALL=(ALL) NOPASSWD: ALL


This has to be the last line in the file. It is important that this is the last line, otherwise it will be overridden.

NB: Always edit the sudoers file using the visudo command. This will verify your changes before saving the file - this can save you from accidentally locking yourself out of the machine completely.

Once you've done this you should be able to execute the following command on the wordpress-server without supplying a password:


		#
		sudo echo "Hello"


Now, throughout this tutorial, you can run the ansible-playbook commands without the -K flag, so you don't have to enter the sudo password manually.


$ ansible-playbook playbook.yml -i hosts -u sammy
---


Step 1  Installing Ansible
+++

In this section we'll install Ansible on your build-server.

SSH in to your build-server and run this command to install Ansible:


		#
		sudo apt-get install ansible -y 

You can make sure that Ansible is installed by running:


		#
		ansible --version

You should see output something like:


		#
		ansible 1.5.4



Step 2  Setting Up the File Structure
+++

Now that we've installed Ansible, let's get prepare the file structure for our Ansible playbook.

Create a directory for our playbook.


		#
		cd ~
		mkdir wordpress-ansible && cd wordpress-ansible



cd into this directory and create two files: one called playbook.yml (this is where we'll write the commands to install WordPress) and another called hosts (this tells Ansible on which servers to run the commands):


		#
		touch playbook.yml
		touch hosts


It is best practice to split our playbooks up into roles. You can think of roles as re-usable modules. For this project we'll create four roles: 


    - server
    - php
    - mysql
    - wordpress


From the project root folder (~/wordpress-ansible), create a directory called roles and cd into it:


		#
		mkdir roles && cd roles


We can bootstrap our roles with an Ansible tool called ansible-galaxy. For each role that we want to create, we will run ansible-galaxy init:


$ ansible-galaxy init server
---

		#
		ansible-galaxy init server 
		ansible-galaxy init php 
		ansible-galaxy init mysql
		ansible-galaxy init wordpress


You'll notice that this creates a whole file structure for each of our roles. This is in accordance with Ansible's best practices. For the most part we will be concerned with each role's tasks/main.yml file.

At this point we should have the following file structure:


		#
		[.]
		|_ playbook.yml
		|_ hosts
		|_ [roles]
			  |_ [server]
					|_ ...
			  |_ [php]
					|_ ...
			  |_ [mysql]
					|_ ...
			  |_ [wordpress]
					|_ ...                                    



Step 3  Writing the Playbook
+++

In this section, we'll write the commands to install WordPress on our remote server. 

Inventory (hosts file)
---


An Ansible inventory informs Ansible about what servers we have that we want to install WordPress on. We can run our playbooks for the servers or groups of servers defined in our inventory file (hosts). Our inventory is very simple.

Edit hosts:


		#
		nano ~/wordpress-ansible/hosts



Add the line for [wordpress], and below it, the IP address of your wordpress-server:


		#
		[wordpress]
		wordpress_server_ip


MY_NOTE:
The hosts file I used.


		#
		$ cat hosts
		[wordpress]
		test_machine ansible_host=127.0.0.1 ansible_port=2222 ansible_user=vagrant


You could put a number of different IPs under the [wordpress] group. This would cause the commands to be run on all servers listed here, provided you have access set up on all the servers. This would let you install WordPress on a number of different servers at once.


Playbook
---

We can think of a playbook as the definition of our WordPress app. Our playbook will combine the roles we created to configure a useful application (in this case a WordPress site).

Edit the playbook file:


		#
		nano ~/wordpress-ansible/playbook.yml


Add these contents, which tell Ansible which hosts to run the roles on (the wordpress ones in the hosts file), and which roles to run:


		#
		#
		---
		- hosts: wordpress
		  roles:
			- server
			- php
			- mysql
			- wordpress


Move to your playbook directory:


Let's make sure our basic connection from the build-server to the wordpress-server works by running the playbook. It won't do anything yet; it'll just test the connection: 


$ ansible-playbook playbook.yml -i hosts -u sammy -K
~~~

Enter the sudo password for your sudo user on the wordpress-server when prompted.

You should see output something like:


		#
		PLAY [wordpress] ************************************************************** 

		GATHERING FACTS *************************************************************** 
		ok: [188.166.68.134]

		PLAY RECAP ******************************************************************** 
		188.166.68.134             : ok=1    changed=0    unreachable=0    failed=0 


This indicates that we were able to connect to the server. However, we haven't defined any plays yet, so nothing was executed on our wordpress-server. Let's fix that by filling out the details in our four roles.

If this was not successful, double-check that you can SSH from the build-server to the wordpress-server using an SSH key.


Step 3  Creating Roles
+++

Server
---

First things first; let's set up our server. For this we'll be editing the server role.

The server role will install all the software we need on the target server. Edit this file:


		#
		nano roles/server/tasks/main.yml`



Add the following contents; make sure there's only one line with --- (there should be one there by default):


		#
		#
		---
		- name: Update apt cache
		  apt: update_cache=yes cache_valid_time=3600
		  sudo: yes

		- name: Install required software
		  apt: name={{ item }} state=present
		  sudo: yes
		  with_items:
			- apache2
			- mysql-server
			- php5-mysql
			- php5
			- libapache2-mod-php5
			- php5-mcrypt
			- python-mysqldb


This does the following:


    - Update the apt-cache (apt-get update)
    - apt-get install Apache, MySQL, PHP, and related software


If you're interested in the details of what we're installing, you can have have a look at the tutorial on how to manually install LAMP on Ubuntu 14.04.

We can now run our playbook like so: 


$ ansible-playbook playbook.yml -i hosts -u sammy -K
~~~


You should see output something like this:


		#
		PLAY [wordpress] ************************************************************** 

		GATHERING FACTS *************************************************************** 
		ok: [188.166.68.134]

		TASK: [server | Update apt cache] ********************************************* 
		ok: [188.166.68.134]

		TASK: [server | Install required software] ************************************ 
		changed: [188.166.68.134] => (item=apache2,mysql-server,php5-mysql,php5,libapache2-mod-php5,php5-mcrypt,python-mysqldb)

		PLAY RECAP ******************************************************************** 
		188.166.68.134             : ok=3    changed=1    unreachable=0    failed=0  


After running this, you should be able to access the default Apache page at http://wordpress_server_ip/. Awesome. Apache is now installed and running on the wordpress-server.

If your build hangs indefinitely at the point of TASK: [server | Update apt cache], this can indicate a lack of permissions on the target server. Make sure sudo access is configured properly on the wordpress-server.


PHP
---

Let's sort out our PHP requirements. We'll be doing this in the PHP role. Edit the main tasks file for PHP:


		#
		nano roles/php/tasks/main.yml


Add the following (again, the --- line should already be there):


		#
		---
		- name: Install php extensions
		  apt: name={{ item }} state=present
		  sudo: yes
		  with_items:
			- php5-gd 
			- libssh2-php


This will install the required PHP extensions.


MySQL
---

We also need to set up a MySQL database for our WordPress site. We'll do this in the mysql role.

We're going to need a few variables for this one. For a role, you can specify default values for any variables in the defaults/main.yml file.



		#
		nano roles/mysql/defaults/main.yml



Add your database name, database username, and database password (that you want to create), in that order. Make sure you pick a secure wp_db_password.


		#
		#
		---
		wp_mysql_db: wordpress
		wp_mysql_user: wordpress
		wp_mysql_password: wp_db_password



Add the tasks to create our database and a user to access it. 


		#
		nano roles/mysql/tasks/main.yml


Add the following contents:


		#
		#
		---
		- name: Create mysql database
		  mysql_db: name={{ wp_mysql_db }} state=present

		- name: Create mysql user
		  mysql_user: 
			name={{ wp_mysql_user }} 
			password={{ wp_mysql_password }} 
			priv=*.*:ALL


This role does the following:



    - Create a MySQL database
    - Create a MySQL user
    - Give that user access to our database


The variables are pulled in automatically from our earlier file, so you don't have to change anything here.

You might be interested in encrypting your password. Ansible provides ansible-vault as a utility for this, but a full discussion of ansible-vault is beyond the scope of this tutorial.


WordPress
---

And now, the moment we've all been waiting for... WordPress!

With the server requirements installed, we can set up WordPress. We'll be editing the wordpress role.

We're adding a few different tasks to the roles/wordpress/tasks/main.yml file, so keep it open for this section.


		#
		$ nano roles/wordpress/tasks/main.yml



First we need to download WordPress to the /tmp directory (the security-conscious among you will notice that we have disabled certificate validation, which would interrupt the download):


		#
		---
		- name: Download WordPress  get_url: 
			url=https://wordpress.org/latest.tar.gz 
			dest=/tmp/wordpress.tar.gz
			validate_certs=no 
			sudo: yes



Once downloaded, we extract the gzip file to /var/www, the location that Apache uses for storing web content: 


		#
		- name: Extract WordPress  unarchive: src=/tmp/wordpress.tar.gz dest=/var/www/ copy=no 
		  sudo: yes



With the files extracted, let's update Apache's default site document root to point to our WordPress site:


		#
		- name: Update default Apache site
		  sudo: yes
		  lineinfile: 
			dest=/etc/apache2/sites-enabled/000-default.conf 
			regexp="(.)+DocumentRoot /var/www/html"
			line="DocumentRoot /var/www/wordpress"
		  notify:
			- restart apache
		  sudo: yes


This will update the DocumentRoot for Apache's default site to point to the WordPress files that we downloaded at /var/www/wordpress

You'll notice here that we've added a notify block. This is used when you need to perform tasks such as restarting services after a task has successfully completed. notify handlers will only be notified if our task is changed.

We need to add our handler for restart apache. Save what you have so far, and open roles/wordpress/handlers/main.yml for editing:


		#
		nano roles/wordpress/handlers/main.yml


Add these contents:


		#
		#
		---
		- name: restart apache
		  service: name=apache2 state=restarted
		  sudo: yes      


This handler will be called when a task that specifies notify: restart apache is changed, causing the server to restart Apache.


Configuring WordPress
---

Back to roles/wordpress/tasks/main.yml.

Finally, we need to do some configuration for our WordPress site:

First, we copy the sample config file:


		#
		- name: Copy sample config file
		  command: mv /var/www/wordpress/wp-config-sample.php /var/www/wordpress/wp-config.php creates=/var/www/wordpress/wp-config.php
		  sudo: yes


Update some of the constants in this file to match our database information:


		#
		- name: Update WordPress config file
		  lineinfile:
			dest=/var/www/wordpress/wp-config.php
			regexp="{{ item.regexp }}"
			line="{{ item.line }}"
		  with_items:
			- {'regexp': "define\\('DB_NAME', '(.)+'\\);", 'line': "define('DB_NAME', '{{wp_mysql_db}}');"}        
			- {'regexp': "define\\('DB_USER', '(.)+'\\);", 'line': "define('DB_USER', '{{wp_mysql_user}}');"}        
			- {'regexp': "define\\('DB_PASSWORD', '(.)+'\\);", 'line': "define('DB_PASSWORD', '{{wp_mysql_password}}');"}
		  sudo: yes   


This task will find the lines containing: DB_NAME, DB_USER, and DB_PASSWORD in our config file and replace them with the variables from our playbook.

After successfully completing the steps above, our wordpress role will contain two files of interest.

Here's the complete tasks file for WordPress:


		#
		#
		---
		- name: Download WordPress  get_url: 
			url=https://wordpress.org/latest.tar.gz 
			dest=/tmp/wordpress.tar.gz
			validate_certs=no

		- name: Extract WordPress  unarchive: src=/tmp/wordpress.tar.gz dest=/var/www/ copy=no
		  sudo: yes

		- name: Update default Apache site
		  sudo: yes
		  lineinfile: 
			dest=/etc/apache2/sites-enabled/000-default.conf 
			regexp="(.)+DocumentRoot /var/www/html"
			line="DocumentRoot /var/www/wordpress"
		  notify:
			- restart apache

		- name: Copy sample config file
		  command: mv /var/www/wordpress/wp-config-sample.php /var/www/wordpress/wp-config.php creates=/var/www/wordpress/wp-config.php
		  sudo: yes

		- name: Update WordPress config file
		  lineinfile:
			dest=/var/www/wordpress/wp-config.php
			regexp="{{ item.regexp }}"
			line="{{ item.line }}"
		  with_items:
			- {'regexp': "define\\('DB_NAME', '(.)+'\\);", 'line': "define('DB_NAME', '{{wp_mysql_db}}');"}        
			- {'regexp': "define\\('DB_USER', '(.)+'\\);", 'line': "define('DB_USER', '{{wp_mysql_user}}');"}        
			- {'regexp': "define\\('DB_PASSWORD', '(.)+'\\);", 'line': "define('DB_PASSWORD', '{{wp_mysql_password}}');"}
		  sudo: yes



Here's the file for restarting Apache (which you should have created already):


		#
		#
		---
		- name: restart apache
		  service: name=apache2 state=restarted
		  sudo: yes


We're done! Run the playbook one last time to install and configure WordPress:


$ ansible-playbook playbook.yml -i hosts -u sammy -K
~~~


You should be able to view your WordPress site online at: http://your_server_ip.

You can complete the manual WordPress site setup from here.


Conclusion

Congratulations! You can now install a WordPress site on any Ubuntu 14.04 server with a single command:

    ansible-playbook playbook.yml -i hosts -u sammy -K

All you have to do is add the IP address of your target server to your hosts file and make sure your permissions are set correctly.

Next Steps

This was a very quick intro to get you started with Ansible and WordPress. You might be interested in looking into the following improvements:

    - Explore the Ansible Galaxy and learn how you can host your own roles on the Galaxy
    - Automate the setup process so that there is no manual configuration of your WordPress site required



Comments
+++

July 7, 2015

You might want to have a look at our wordpress role for configuring (multiple) wordpress installations
https://github.com/Oefenweb/ansible-wordpress

August 10, 2015

This is a good intro to Ansible + WordPress. If anyone is looking for a more full-featured setup, Trellis is a set of Ansible playbooks/roles to provision a Ubuntu server with everything you'd need for a production WP site. It can also serve as a good example of more complicated Ansible roles/tasks if you want to roll your own.

https://roots.io/trellis/


August 11, 2015

Trellis looks like a pretty complete set of Ansible playbooks for LEMP WP setup. https://github.com/roots/trellis

https://github.com/roots/trellis





Title: how-to-deploy-multiple-php-applications-using-ansible-on-ubuntu-14-04
===
Source:  https://www.digitalocean.com/community/tutorials/how-to-deploy-multiple-php-applications-using-ansible-on-ubuntu-14-04

Added: Wed Dec 14 15:10:28 CET 2016
Created: PostedJune 28, 2015


Tutorial Series
This tutorial is part 3 of 3 in the series: Automating Your PHP Application Deployment Process with Ansible 


Introduction
+++

This tutorial is the third in a series about deploying PHP applications using Ansible on Ubuntu 14.04. The first tutorial covers the basic steps for deploying an application; the second tutorial covers more advanced topics such as databases, queue daemons, and task schedulers (crons).

In this tutorial, we will build on what we learned in the previous tutorials by transforming our single-application Ansible playbook into a playbook that supports deploying multiple PHP applications on one or multiple servers. This is the final piece of the puzzle when it comes to using Ansible to deploy your applications with minimal effort.

We will be using a couple of simple Lumen applications as part of our examples. However, these instructions can be easily modified to support other frameworks and applications if you already have your own. It is recommended that you use the example applications until you are comfortable making changes to the playbook.


Prerequisites
+++



	- Two Droplets set up by following the first and second tutorials in this series.

	- A new (third) Ubuntu 14.04 Droplet set up like the original PHP Droplet in the first tutorial, with a sudo non-root user and SSH keys. This Droplet which will be used to show how to deploy multiple applications to multiple servers using one Ansible playbook. We'll refer to the IP addresses of the original PHP Droplet and this new PHP Droplet as your_first_server_ip and your_second_server_ip respectively.

	- An updated /etc/hosts file on your local computer with the following lines added. You can learn more about this file in step 6 of this tutorial.


		#
		your_first_server_ip laravel.example.com one.example.com two.example.com
		your_second_server_ip laravel.example2.com two.example2.com

The example websites we'll use in this tutorial are laravel.example.com, one.example.com, and two.example.com. If you want to use your own domain, you'll need to update your active DNS records instead.


Step 1  Setting Playbook Variables
+++

In this step, we will set up playbook variables to define our new applications.

In the previous tutorials, we hard-coded all of the configuration specifics, which is normal for many playbooks that perform specific tasks for a specific application. However, when you wish to support multiple applications or broaden the scope of your playbook, it no longer makes sense to hard code everything.


As we have seen before, Ansible provides variables which you can use in both your task definitions and file templates. What we haven't seen yet is how to manually set variables. In the top of your playbook, alongside the hosts and tasks parameters, you can define a vars parameter, and set your variables there.

If you haven't done so already, change directories into ansible-php from the previous tutorials.


		#
		cd ~/ansible-php/


Open up our existing playbook for editing.


		#
		nano php.yml


The top of the file should look like this:


		#
		#
		---
		- hosts: php
		  sudo: yes

		  tasks:
		. . .



To define variables, we can just add in a vars section in, alongside hosts, sudo, and tasks. To keep things simple, we will start with a very basic variable for the www-data user name, like so:


		#
		#
		---
		- hosts: php
		  sudo: yes

		  vars:
			wwwuser: www-data

		  tasks:
		. . .


Next, go through and update all occurrences of the www-data user with the new variable {{ wwwuser }}. This format should be familiar, as we have used it within looks and for lookups.


To find and replace using nano, press CTRL+\. You'll see a prompt which says Search (to replace):. Type www-data , then press ENTER. The prompt will change to Replace with:. Here, type {{ wwwuser }} and press ENTER again. Nano will take you through each instance of www-data and ask Replace this instanace?. You can press y to replace each one by one, or a to replace all.

Note: Make sure the variable declaration that we just added at the top isn't changed too. There should be 11 instances of www-data that need to be replaced.


Before we go any further, there is something we need to be careful of when it comes to variables. Normally we can just add them in like this, when they are within a longer line:


		#
		- name: create /var/www/ directory
		  file: dest=/var/www/ state=directory owner={{ wwwuser }} group={{ wwwuser }} mode=0700



However, if the variable is the only value in the string, we need to wrap it in quotes so the YAML parser can correctly understand it:


		#
		- name: Run artisan migrate
		  shell: php /var/www/laravel/artisan migrate --force
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  when: dbpwd.changed



In your playbook, this needs to happen any time you have sudo_user: {{ wwwuser }}. You can use a global find and replace the same way, replacing sudo_user: {{ wwwuser }} with sudo_user: "{{ wwwuser }}". There should be four lines that need this change.

Once you have changed all occurrences, save and run the playbook:

$ ansible-playbook php.yml --ask-sudo-pass
---


There should be no changed tasks, which means that our wwwuser variable is working correctly.


Step 2  Defining Nested Variables for Complex Configuration
+++

In this section, we will look at nesting variables for complex configuration options.

In the previous step, we set up a basic variable. However, it is also possible to nest variables and define lists of variables. This provides the functionality we need to define the list of sites we wish to set up on our server.

First, let us consider the existing git repository that we have set up in our playbook:


		#
		- name: Clone git repository
		  git: >
			dest=/var/www/laravel
			repo=https://github.com/do-community/do-ansible-adv-php.git
			update=yes
			version=example


We can extract the following useful pieces of information: name (directory), repository, branch, and domain. Because we are setting up multiple applications, we will also need a domain name for it to respond to. Here, we'll use laravel.example.com, but if you have your own domain, you can substitute it.

This results in the following four variables that we can define for this application:


		#
		name: laravel
		repository: https://github.com/do-community/do-ansible-adv-php.git
		branch: example
		domain: laravel.example.com


Now, open up your playbook for editing.

In the top vars section, we can add in our application into a new application list:


		#
		#
		---
		- hosts: php
		  sudo: yes

		  vars:
			wwwuser: www-data

			applications:
			  - name: laravel
				domain: laravel.example.com
				repository: https://github.com/do-community/do-ansible-adv-php.git
				branch: example

		...



If you run your playbook now (using ansible-playbook php.yml --ask-sudo-pass), nothing will change because we haven't yet set up our tasks to use our new applications variable yet. However, if you go to http://laravel.example.com/ in your browser, it should show our original application.


Step 3  Looping Variables in Tasks
+++

In this section we will learn how to loop through variable lists in tasks.

As mentioned previously, variable lists need looped over in each task that we wish to use them in. As we saw with the install packages task, we need to define a loop of items, and then apply the task for each item in the list.

Open up your playbook for editing.

We will start with some easy tasks first. Around the middle of your playbook, you should find these two env tasks:


		#
		#
		- name: set APP_DEBUG=false
		  lineinfile: dest=/var/www/laravel/.env regexp='^APP_DEBUG=' line=APP_DEBUG=false

		- name: set APP_ENV=production
		  lineinfile: dest=/var/www/laravel/.env regexp='^APP_ENV=' line=APP_ENV=production


You will notice that they are currently hard-coded with the laravel directory. We want to update it to use the name property for each application. To do this we add in the with_items option to loop over our applications list. Within the task itself, we will swap out the laravel reference for the variable {{ item.name }}, which should be familiar from the formats we've used before.


It should look like this:


		#
		#
		- name: set APP_DEBUG=false
		  lineinfile: dest=/var/www/{{ item.name }}/.env regexp='^APP_DEBUG=' line=APP_DEBUG=false
		  with_items: applications

		- name: set APP_ENV=production
		  lineinfile: dest=/var/www/{{ item.name }}/.env regexp='^APP_ENV=' line=APP_ENV=production
		  with_items: applications


Next, move down to the two Laravel artisan cron tasks. They can be updated exactly the same as we just did with the env tasks. We will also add in the item.name into the name parameter for the cron entries, as Ansible uses this field to uniquely identify each cron entry. If we left them as-is, we would not be able to have multiple sites on the same server as they would overwrite each over constantly and only the last one would be saved.

The tasks should look like this:


		#
		#
		- name: Laravel Scheduler
		  cron: >
			job="run-one php /var/www/{{ item.name }}/artisan schedule:run 1>> /dev/null 2>&1"
			state=present
			user={{ wwwuser }}
			name="{{ item.name }} php artisan schedule:run"
		  with_items: applications

		- name: Laravel Queue Worker
		  cron: >
			job="run-one php /var/www/{{ item.name }}/artisan queue:work --daemon --sleep=30 --delay=60 --tries=3 1>> /dev/null 2>&1"
			state=present
			user={{ wwwuser }}
			name="{{ item.name }} Laravel Queue Worker"
		  with_items: applications


If you save and run the playbook now (using ansible-playbook php.yml --ask-sudo-pass), you should only see the two updated cron tasks as updated. This is due to the change in the name parameter. Apart from that, there have been no changes, and this means that our applications list is working as expected, and we have not yet made any changes to our server as a result of refactoring our playbook.



Step 4  Applying Looped Variables in Templates
+++

In this section we will cover how to use looped variables in templates.

Looping variables in templates is very easy. They can be used in exactly the same way that they are used in tasks, like all other variables. The complexity comes in when you consider file paths as well as variables, as in some uses we need to factor in the file name and even run other commands because of the new file.

In the case of Nginx, we need to create a new configuration file for each application, and tell Nginx that it should be enabled. We also want to remove our original /etc/nginx/sites-available/default configuration file in the process.

First, open up your playbook for editing.

Find the Configure Nginx task (near the middle of the playbook), and update it as we have done with the other tasks:


		#
		- name: Configure nginx
		  template: src=nginx.conf dest=/etc/nginx/sites-available/{{ item.name }}
		  with_items: applications
		  notify:
			- restart php5-fpm
			- restart nginx



While we are here, we will also add in two more tasks that were mentioned above. First, we will tell Nginx about our new site configuration file. This is done with a symlink between the sites-available and sites-enabled directories in /var/nginx/.

Add this task after the Configure nginx task:


		#
		- name: Configure nginx symlink
		  file: src=/etc/nginx/sites-available/{{ item.name }} dest=/etc/nginx/sites-enabled/{{ item.name }} state=link
		  with_items: applications
		  notify:
			- restart php5-fpm
			- restart nginx


Next, we want to remove the default enabled site configuration file so it doesn't cause problems with our new site configuration files. This is done easily with the file module:


		#
		- name: Remove default nginx site
		  file: path=/etc/nginx/sites-enabled/default state=absent
		  notify:
			- restart php5-fpm
			- restart nginx


Note that we didn't need to loop applications, as we were looking for a single file.

The Nginx block in your playbook should now look like this:


		#
		- name: Configure nginx
		  template: src=nginx.conf dest=/etc/nginx/sites-available/{{ item.name }}
		  with_items: applications
		  notify:
			- restart php5-fpm
			- restart nginx

		- name: Configure nginx symlink
		  file: src=/etc/nginx/sites-available/{{ item.name }} dest=/etc/nginx/sites-enabled/{{ item.name }} state=link
		  with_items: applications
		  notify:
			- restart php5-fpm
			- restart nginx

		- name: Remove default nginx site
		  file: path=/etc/nginx/sites-enabled/default state=absent
		  notify:
			- restart php5-fpm
			- restart nginx


Save your playbook and open the nginx.conf file for editing.

Update the configuration file so it uses our variables:


		#
		server {
			listen 80 default_server;
			listen [::]:80 default_server ipv6only=on;

			root /var/www/{{ item.name }}/public;
			index index.php index.html index.htm;

			server_name {{ item.domain }};

			location / {
				try_files $uri $uri/ =404;
			}

			error_page 404 /404.html;
			error_page 500 502 503 504 /50x.html;
			location = /50x.html {
				root /var/www/{{ item.name }}/public;
			}

			location ~ \.php$ {
				try_files $uri =404;
				fastcgi_split_path_info ^(.+\.php)(/.+)$;
				fastcgi_pass unix:/var/run/php5-fpm.sock;
				fastcgi_index index.php;
				fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
				include fastcgi_params;
			}
		}



However, we haven't finished yet. Notice the default_server at the top? We want to only include that for the laravel application, to make it the default. To do this we can use a basic IF statement to check if item.name is equal to laravel, and if so, display default_server.


It will look like this:


		#
		server {
			listen 80{% if item.name == "laravel" %} default_server{% endif %};
			listen [::]:80{% if item.name == "laravel" %} default_server ipv6only=on{% endif %};


Update your nginx.conf accordingly and save it.

Now it is time to run our playbook:


		#
		ansible-playbook php.yml --ask-sudo-pass

You should notice the Nginx tasks have been marked as changed. When it finishes running, refresh the site in your browser and it should be displaying the same as it did at the end of the last tutorial:


		#
		Queue: YES
		Cron: YES



Step 5  Looping Multiple Variables Together
+++


In this step we will loop multiple variables together in tasks.

Now it is time to tackle a more complex loop example, specifically registered variables. In order to support different states and prevent tasks from running needlessly, you will remember that we used register: cloned in our Clone git repository task to register the variable cloned with the state of the task. We then used when: cloned|changed in the following tasks to trigger tasks conditionally. Now we need to update these references to support the applications loop.

First, open up your playbook for editing.

Look down for the Clone git repository task:


		#
		- name: Clone git repository
		  git: >
			dest=/var/www/laravel
			repo=https://github.com/do-community/do-ansible-adv-php.git
			update=yes
			version=example
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  register: cloned



As we're registering the variable in this task, we don't need to do anything that we haven't already done:


		#
		- name: Clone git repository
		  git: >
			dest=/var/www/{{ item.name }}
			repo={{ item.repository }}
			update=yes
			version={{ item.branch }}
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  with_items: applications
		  register: cloned


Now, move down your playbook until you find the composer create-project task:


		#
		- name: composer create-project
		  composer: command=create-project working_dir=/var/www/laravel optimize_autoloader=no
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  when: cloned|changed


Now we need to update it to loop through both applications and cloned. This is done using the with_together option, and passing in both applications and cloned. As with_together loops through two variables, accessing items is done with item.#, where # is the index of the variable as it is defined. So for example:


		#
		with_together:
		- list_one
		- list_two


item.0 will refer to list_one, and item.1 will refer to list_two.



Which means that for applications we can access the properties via: item.0.name. For cloned we need to pass in the results from the tasks, which can be accessed via cloned.results, and then we can check if it was changed via item.1.changed.


This means the task becomes:


		#
		- name: composer create-project
		  composer: command=create-project working_dir=/var/www/{{ item.0.name }} optimize_autoloader=no
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  when: item.1.changed
		  with_together:
			- applications
			- cloned.results


Now save and run your playbook:


		#
		ansible-playbook php.yml --ask-sudo-pass

There should be no changes from this run. However, we now have a registered variable working nicely within a loop.


Step 6  Complex Registered Variables and Loops
+++


In this section we will learn about more complicated registered variables and loops.

The most complicated part of the conversion is handling the registered variable we are using for password generation for our MySQL database. That said, there isn't much more that we have to do in this step that we haven't covered, we just need to update a number of tasks at once.

Open your playbook for editing.

Find the MySQL tasks, and in our initial pass we will just add in the basic variables like we have done in previous tasks:


		#
		#
		- name: Create MySQL DB
		  mysql_db: name={{ item.name }} state=present
		  with_items: applications

		- name: Generate DB password
		  shell: makepasswd --chars=32
		  args:
			creates: /var/www/{{ item.name }}/.dbpw
		  with_items: applications
		  register: dbpwd

		- name: Create MySQL User
		  mysql_user: name={{ item.name }} password={{ dbpwd.stdout }} priv={{ item.name }}.*:ALL state=present
		  when: dbpwd.changed

		- name: set DB_DATABASE
		  lineinfile: dest=/var/www/{{ item.name }}/.env regexp='^DB_DATABASE=' line=DB_DATABASE={{ item.name }}
		  with_items: applications

		- name: set DB_USERNAME
		  lineinfile: dest=/var/www/{{ item.name }}/.env regexp='^DB_USERNAME=' line=DB_USERNAME={{ item.name }}
		  with_items: applications

		- name: set DB_PASSWORD
		  lineinfile: dest=/var/www/{{ item.name }}/.env regexp='^DB_PASSWORD=' line=DB_PASSWORD={{ dbpwd.stdout }}
		  when: dbpwd.changed

		- name: Save dbpw file
		  lineinfile: dest=/var/www/{{ item.name }}/.dbpw line="{{ dbpwd.stdout }}" create=yes state=present
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  when: dbpwd.changed

		- name: Run artisan migrate
		  shell: php /var/www/{{ item.name }}/artisan migrate --force
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  when: dbpwd.changed


Next we will add in with_together so we can use our database password. For our password generation, we need to loop over dbpwd.results, and will be able to access the password from item.1.stdout, since applications will be accessed via item.0.


We can update our playbook accordingly.


		#
		- name: Create MySQL DB
		  mysql_db: name={{ item.name }} state=present
		  with_items: applications

		- name: Generate DB password
		  shell: makepasswd --chars=32
		  args:
			creates: /var/www/{{ item.name }}/.dbpw
		  with_items: applications
		  register: dbpwd

		- name: Create MySQL User
		  mysql_user: name={{ item.0.name }} password={{ item.1.stdout }} priv={{ item.0.name }}.*:ALL state=present
		  when: item.1.changed
		  with_together:
		  - applications
		  - dbpwd.results

		- name: set DB_DATABASE
		  lineinfile: dest=/var/www/{{ item.name }}/.env regexp='^DB_DATABASE=' line=DB_DATABASE={{ item.name }}
		  with_items: applications

		- name: set DB_USERNAME
		  lineinfile: dest=/var/www/{{ item.name }}/.env regexp='^DB_USERNAME=' line=DB_USERNAME={{ item.name }}
		  with_items: applications

		- name: set DB_PASSWORD
		  lineinfile: dest=/var/www/{{ item.0.name }}/.env regexp='^DB_PASSWORD=' line=DB_PASSWORD={{ item.1.stdout }}
		  when: item.1.changed
		  with_together:
		  - applications
		  - dbpwd.results

		- name: Save dbpw file
		  lineinfile: dest=/var/www/{{ item.0.name }}/.dbpw line="{{ item.1.stdout }}" create=yes state=present
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  when: item.1.changed
		  with_together:
		  - applications
		  - dbpwd.results

		- name: Run artisan migrate
		  shell: php /var/www/{{ item.0.name }}/artisan migrate --force
		  sudo: yes
		  sudo_user: "{{ wwwuser }}"
		  when: item.1.changed
		  with_together:
		  - applications
		  - dbpwd.results


Once you have updated your playbook, save it and run it:

		#
		ansible-playbook php.yml --ask-sudo-pass

Despite all of the changes we've made to our playbook, there should be no changes to the database tasks. With the changes in this step, we should have finished our conversion from a single application playbook to a multiple application playbook.

MY_NOTE:
Didn't finish this tutorial, nor do I plan to do so.




Title: configuration-management-101-writing-ansible-playbooks
===
Source: https://www.digitalocean.com/community/tutorials/configuration-management-101-writing-ansible-playbooks

Added: Thu Dec 22 14:01:08 CET 2016
Created: PostedMarch 24, 2016 


Tutorial Series
This tutorial is part 2 of 4 in the series: Getting Started with Configuration Management 


Introduction
+++

In a nutshell, server configuration management (also popularly referred to as IT Automation) is a solution for turning your infrastructure administration into a codebase, describing all processes necessary for deploying a server in a set of provisioning scripts that can be versioned and easily reused. It can greatly improve the integrity of any server infrastructure over time.

In a previous guide, we talked about the main benefits of implementing a configuration management strategy for your server infrastructure, how configuration management tools work, and what these tools typically have in common.

This part of the series will walk you through the process of automating server provisioning using Ansible, a configuration management tool that provides a complete automation framework and orchestration capabilities, while maintaining a goal of ultimate simplicity and minimalism. We will focus on the language terminology, syntax, and features necessary for creating a simplified example to fully automate the deployment of an Ubuntu 14.04 web server using Apache.

This is the list of steps we need to automate in order to reach our goal:

    - Update the apt cache
	- Install Apache
	- Create a custom document root directory
	- Place an index.html file in the custom document root
	- Apply a template to set up our custom virtual host
	- Restart Apache


We will start by having a look at the terminology used by Ansible, followed by an overview of the main language features that can be used to write playbooks. At the end of this guide, we will share the complete example so you can try it by yourself.


Note: this guide is intended to get you introduced to the Ansible language and how to write playbooks to automate your server provisioning. For a more introductory view of Ansible, including the steps necessary for installing and getting started with this tool, check our How to Install and Configure Ansible on Ubuntu 14.04 guide.


Getting Started
+++

Before we can move to a more hands-on view of Ansible, it is important that we get acquainted with important terminology and concepts introduced by this tool.

Ansible Terms
---


    - Controller Machine: the machine where Ansible is installed, responsible for running the provisioning on the servers you are managing
    - Inventory: an INI file that contains information about the servers you are managing
    - Playbook: the entry point for Ansible provisionings, where the automation is defined through tasks using YAML format
    - Task: a block that defines a single procedure to be executed, e.g.: install a package
    - Module: a module typically abstracts a system task, like dealing with packages or creating and changing files. Ansible has a multitude of built-in modules, but you can also create custom ones
    - Role: a pre-defined way for organizing playbooks and other files in order to facilitate sharing and reusing portions of a provisioning
    - Play: a provisioning executed from start to finish is called a play
    - Facts: global variables containing information about the system, like network interfaces or operating system
    - Handlers: used to trigger service status changes, like restarting or stopping a service


Ansible provisionings are written using YAML, a simple data serialization language.

Tasks
---

A task defines a single step that should be executed by the provisioning. It typically involves the usage of a module or the execution of a raw command (which, in reality, is just a module created to handle raw commands). This is how a task looks:


		#
		- name: This is a task
		  apt: pkg=vim state=latest



The name part is actually optional, but recommended, as shows up in the output of the provisioning when the task is executed. The apt part is a built-in Ansible module that abstracts the management of packages on Debian-based distributions. This tasks tells Ansible that the package vim should have its state changed to latest, which will cause the package manager to install this package in case it is not installed yet.


Playbook Format
---

Playbooks are the entry point of an Ansible provisioning. They contain information about the systems where the provisioning should be executed, as well as the directives or steps that should be executed. Below you can find an example of a simple playbook that perform two tasks: updates the apt cache and installs vim afterwards:



		#
		#
		---
		- hosts: all
		  become: true
		  tasks:
			 - name: Update apt-cache 
			   apt: update_cache=yes

			 - name: Install Vim
			   apt: name=vim state=latest



YAML relies on indentation to serialize data structures. For that reason, when writing playbooks and especially when copying examples, you need to be extra careful to maintain the correct indentation. 

Before the end of this guide we will see a more real-life example of a playbook, explained in detail. The next section will give you an overview of the most important elements and features that can be used to write Ansible playbooks.


Writing Playbooks
+++

Working with Variables
---

There are different ways in which you can define variables in Ansible. The simplest way is by using the vars section of a playbook. The example below defines a variable package that later is used inside a task:


		#
		#
		---
		- hosts: all
		  become: true
		  vars:
			 package: vim
		  tasks:
			 - name: Install Package
			   apt: name={{ package }} state=latest



The variable package can be accessed from any point of the provisioning, even included files and templates.


Using Loops
---

Loops are typically used to repeat a task using different input values. For instance, instead of creating 10 tasks for installing 10 different packages, you can create a single task and use a loop to repeat the task with all the different packages you want to install.

To create a loop within a task, include the option with_items with an array of values. The content can be accessed through the loop variable item, as shown in the example below:


		#
		- name: Install Packages
		  apt: name={{ item }} state=latest
		  with_items:
			 - vim
			 - git
			 - curl  


You can also use an array variable to define your items:


		#
		#
		---
		- hosts: all
		  sudo: true
		  vars:
			 packages: [ 'vim', 'git', 'curl' ]
		  tasks:
			 - name: Install Package
			   apt: name={{ item }} state=latest
			   with_items: packages


Using Conditionals
---

Conditionals can be used to dynamically decide whether or not a task should be executed, based on a variable or an output from a command, for instance.

Below is an example of a task that will only be executed on Debian based systems:


		#
		- name: Shutdown Debian Based Systems
		  command: /sbin/shutdown -t now
		  when: ansible_os_family == "Debian"


The conditional when receives as argument an expression to be evaluated. The task only gets executed in case the expression is true. In this case, we tested a fact to see if the system is from the Debian family.


A common use case for conditionals in IT automation is when the execution of a task depends on the output of a command. With Ansible, the way we implement this is by registering a variable to hold the results a command execution, and then testing this variable in a subsequent task. We can test for the command's exit status (if failed or successful). We can also check for specific contents inside the output, although this might require the usage of regex expressions and string parsing commands. 


The example below shows two conditional tasks based on the output from a php -v command. We will test for the exit status of the command, since it will fail to execute in case PHP is not installed on this server. The ignore_errors portion of the task is important to make sure the provisioning continues even when the command fails execution.


		#
		- name: Check if PHP is installed
		  register: php_installed
		  command: php -v
		  ignore_errors: true

		- name: This task is only executed if PHP is installed
		  debug: var=php_installed
		  when: php_installed|success

		- name: This task is only executed if PHP is NOT installed
		  debug: msg='PHP is NOT installed'
		  when: php_installed|failed


The debug module used here is a useful module for showing contents of variables or debug messages. It can either print a string (when using the msg argument) or print the contents of a variable (when using the var argument).


Working with Templates
---

Templates are typically used to set up configuration files, allowing for the use of variables and other features intended to make these files more versatile and reusable. Ansible uses the Jinja2 template engine.

Below is an example of a template for setting up an Apache virtual host, using a variable for setting up the document root for this host:


		#
		<VirtualHost *:80>
			ServerAdmin webmaster@localhost
			DocumentRoot {{ doc_root }}

			<Directory {{ doc_root }}>
				AllowOverride All
				Require all granted
			</Directory>
		</VirtualHost>


The built-in module template is used to apply the template from a task. If you named the template file above vhost.tpl, and you placed it in the same directory as your playbook, this is how you would apply the template to replace the default Apache virtual host:


		#
		- name: Change default Apache virtual host
		  template: src=vhost.tpl dest=/etc/apache2/sites-available/000-default.conf


Defining and Triggering Handlers
---

Handlers are used to trigger a state change in a service, such as a restart or a stop. Handlers have a behavior very similar to tasks, being executed once in the same order they are defined, however they are only executed if previously triggered from a notify directive in a task. Handlers are typically defined as an array in a handlers section of the playbook.


Let's take into consideration our previous template usage example, where we set up an Apache virtual host. If you want to make sure Apache is restarted after a virtual host change, you first need to create a handler for the Apache service. This is how handlers are defined inside a playbook:


		#
		handlers:
			- name: restart apache
			  service: name=apache2 state=restarted

			- name: other handler
			  service: name=other state=restarted


The name directive here is important because it will be the unique identifier of this handler. To trigger this handler from a task, you should use the notify option:


		#
		- name: Change default Apache virtual host
		  template: src=vhost.tpl dest=/etc/apache2/sites-available/000-default.conf
		  notify: restart apache


Example Playbook
+++

Now let's have a look at a playbook that will automate the installation of an Apache web server within an Ubuntu 14.04 system, as discussed in this guide's introduction.

The complete example, including the template file for setting up Apache and an HTML file to be served by the web server, can be found on Github. The folder also contains a Vagrantfile that lets you test the playbook in a simplified setup, using a virtual machine managed by Vagrant.

Below you can find the complete playbook:


		#
		#
		---
		- hosts: all
		  become: true
		  vars:
			doc_root: /var/www/example
		  tasks:
			- name: Update apt
			  apt: update_cache=yes

			- name: Install Apache
			  apt: name=apache2 state=latest

			- name: Create custom document root
			  file: path={{ doc_root }} state=directory owner=www-data group=www-data

			- name: Set up HTML file
			  copy: src=index.html dest={{ doc_root }}/index.html owner=www-data group=www-data mode=0644

			- name: Set up Apache virtual host file
			  template: src=vhost.tpl dest=/etc/apache2/sites-available/000-default.conf
			  notify: restart apache
		  handlers:
			- name: restart apache
			  service: name=apache2 state=restarted


Playbook Explained
---

hosts: all
~~~
The playbook starts by stating that it should be applied to all hosts in your inventory (hosts: all). It is possible to restrict the playbookâ€™s execution to a specific host, or a group of hosts.

become: true
~~~
The become: true portion tells Ansible to use privilege escalation (sudo) for executing all the tasks in this playbook. This option can be overwritten on a task-by-task basis.

vars
~~~
Defines a variable, doc_root, that is later used in a task. This section could contain multiple variables.

tasks
~~~
The section where the actual tasks are defined. The first updates the apt cache, and the second task installs the package apache2.

The third task uses the built-in module file to create a directory to serve as our document root. This module can be used to manage files and directories.

The fourth task uses the module copy to copy a local file to the remote server. We're copying a simple HTML file to be served as our website hosted by Apache.

handlers
~~~
Finally, we have the handlers section, where the services are declared. We define the restart apache handler that is notified from the fourth task, where the Apache template is applied.


Conclusion
+++

Ansible is a minimalist IT automation tool that has a low learning curve, using YAML for its provisioning scripts. It has a great number of built-in modules that can be used to abstract tasks such as installing packages and working with templates. Its simplified infrastructure requirements and simple language can be a good fit for those who are getting started with configuration management. It might, however, lack some advanced features that you can find with more complex tools like Puppet and Chef.

In the next part of this series, we will see a practical overview of Puppet, a popular and well established configuration management tool that uses an expressive and powerful custom DSL based on Ruby to write provisioning scripts.



