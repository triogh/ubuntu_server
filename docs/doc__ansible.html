<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Ansible Documentation</title>
<meta name="generator" content="HTML::TextToHTML v2.51"/>
</head>
<body><!-- #BeginToc -->
<!-- Table of Contents generated by Perl - HTML::Toc -->
<ul>
   <li><a href="#h-1">Ansible Documentation</a>
      <ul>
         <li><a href="#h-1.1">Title: how-to-install-and-configure-ansible-on-an-ubuntu-12-04-vps</a>
            <ul>
               <li><a href="#h-1.1.1">Introduction</a></li>
               <li><a href="#h-1.1.2">How Does Ansible Work?</a></li>
               <li><a href="#h-1.1.3">Install Ansible on an Ubuntu 12.04 VPS</a></li>
               <li><a href="#h-1.1.4">Set Up SSH Keys</a>
                  <ul>
                     <li><a href="#h-1.1.4.1">Create a New SSH Key Pair</a>
                        <ul>
                           <li><a href="#h-1.1.4.1.1">ssh-keygen</a></li>
                        </ul>
                     </li>
                     <li><a href="#h-1.1.4.2">Transfer an Existing SSH Key Pair to Ansible</a></li>
                  </ul>
               </li>
               <li><a href="#h-1.1.5">Configuring Ansible Hosts</a>
                  <ul>
                     <li><a href="#h-1.1.5.1">/etc/ansible/group_vars</a></li>
                     <li><a href="#h-1.1.5.2">/etc/ansible/group_vars/droplet</a></li>
                     <li><a href="#h-1.1.5.3">ansible_ssh_user: root</a></li>
                     <li><a href="#h-1.1.5.4">/etc/ansible/group_vars/all</a></li>
                     <li><a href="#h-1.1.5.5">/etc/ansible/host_vars</a></li>
                  </ul>
               </li>
               <li><a href="#h-1.1.6">Using Simple Ansible Commands</a>
                  <ul>
                     <li><a href="#h-1.1.6.1">$ ansible -m ping all</a></li>
                     <li><a href="#h-1.1.6.2">$ ansible -m ping droplets</a></li>
                     <li><a href="#h-1.1.6.3">$ ansible -m ping host1</a></li>
                     <li><a href="#h-1.1.6.4">$ ansible -m ping host1:host2</a></li>
                     <li><a href="#h-1.1.6.5">$ ansible -m shell -a 'free -m' host1</a></li>
                  </ul>
               </li>
               <li><a href="#h-1.1.7">Comments</a></li>
            </ul>
         </li>
         <li><a href="#h-1.2">Title: how-to-create-ansible-playbooks-to-automate-system-configuration-on-ubuntu</a>
            <ul>
               <li><a href="#h-1.2.1">Introduction</a></li>
               <li><a href="#h-1.2.2">What are Ansible Playbooks?</a></li>
               <li><a href="#h-1.2.3">Exploring a Basic Playbook</a>
                  <ul>
                     <li><a href="#h-1.2.3.1">$ ansible -m apt -a 'whatever' all</a></li>
                  </ul>
               </li>
               <li><a href="#h-1.2.4">Running an Ansible Playbook</a>
                  <ul>
                     <li><a href="#h-1.2.4.1">$ ansible-playbook playbook.yml</a></li>
                     <li><a href="#h-1.2.4.2">$ ansible-playbook nginx.yml</a></li>
                     <li><a href="#h-1.2.4.3">$ ansible-playbook -l host_subset playbook.yml</a></li>
                     <li><a href="#h-1.2.4.4">$ ansible-playbook -l host3 nginx.yml</a></li>
                  </ul>
               </li>
               <li><a href="#h-1.2.5">Adding Features to the Playbook</a></li>
               <li><a href="#h-1.2.6">Add a Default Index File</a></li>
               <li><a href="#h-1.2.7">Registering Results</a></li>
               <li><a href="#h-1.2.8">Comments</a></li>
            </ul>
         </li>
      </ul>
   </li>
</ul>
<!-- End of generated Table of Contents -->
<!-- #EndToc -->
<h1><!-- #BeginTocAnchorNameBegin --><a name="h-1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1">Ansible Documentation</a></h1>

<h2><!-- #BeginTocAnchorNameBegin --><a name="h-1.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1">Title: how-to-install-and-configure-ansible-on-an-ubuntu-12-04-vps</a></h2>
<p>Source: <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-ansible-on-an-ubuntu-12-04-vps">https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-ansible-on-an-ubuntu-12-04-vps</a>
</p>
<p>Added: Thu Dec  1 16:47:12 CET 2016<br/>
Created: PostedFebruary 6, 2014 
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_1">Introduction</a></h3>

<p>Configuration management systems are designed to make controlling large numbers of servers easy for administrators and operations teams. They allow you to control many different systems in an automated way from one central location.
</p>
<p>While there are many popular configuration management systems available for Linux systems, such as Chef and Puppet, these are often more complex than many people want or need. Ansible is a great alternative to these options because it has a much smaller overhead to get started.
</p>
<p>In this guide, we will discuss how to install Ansible on an Ubuntu 12.04 machine and go over some basics of how to use the software.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.2"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_2">How Does Ansible Work?</a></h3>

<p>Ansible works by configuring client machines from an computer with Ansible components installed and configured.
</p>
<p>It communicates over normal SSH channels in order to retrieve information from remote machines, issue commands, and copy files. Because of this, an Ansible system does not require any additional software to be installed on the client computers.
</p>
<p>This is one way that Ansible simplifies the administration of servers. Any server that has an SSH port exposed can be brought under Ansible's configuration umbrella, regardless of what stage it is at in its life cycle.
</p>
<p>Any computer that you can administer through SSH, you can also administer through Ansible.
</p>
<p>Ansible takes on a modular approach, making it easy to extend to use the functionalities of the main system to deal with specific scenarios. Modules can be written in any language and communicate in standard JSON.
</p>
<p>Configuration files are mainly written in the YAML data serialization format due to its expressive nature and its similarity to popular markup languages. Ansible can interact with clients through either command line tools or through its configuration scripts called Playbooks.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.3"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_3">Install Ansible on an Ubuntu 12.04 VPS</a></h3>

<p>To begin exploring Ansible as a means of managing our various servers, we need to install the Ansible software on at least one machine. 
</p>
<dl>
  <dt>MY NOTE</dt>
<dd>Ansible is now available in the default Ubuntu repositories, so there is no need for additional third party repos.
</dd></dl>
<pre>
        #
        sudo apt-get update
        sudo apt-get install ansible
</pre>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.4"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_4">Set Up SSH Keys</a></h3>

<p>As we mentioned above, Ansible primarily communicates with client computers through SSH. While it certainly has the ability to handle password-based SSH authentication, SSH keys help keep things simple.
</p>
<p>We can set up SSH keys in two different ways depending on whether you already have a key you want to use. We will assume that the servers you want to be administering will be DigitalOcean droplets.
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.4.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_4_1">Create a New SSH Key Pair</a></h4>

<p>If you do not already have an SSH key pair that you would like to use for Ansible administration, we can create one now on your Ansible VPS.
</p>
<p>We will create an SSH key pair on our Ansible droplet to authenticate with the hosts that it will administer.
</p>
<p>As the user you will be controlling Ansible with, create an RSA key-pair by typing:
</p>
<h5><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.4.1.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_4_1_1">ssh-keygen</a></h5>

<pre>
        #
        ssh-keygen
</pre>
<p>You will be asked to specify the file location of the created key pair, a passphrase, and the passphrase confirmation. Press ENTER through all of these to accept the default values.
</p>
<p>Your new keys are available in your user's ~/.ssh directory. The public key (the one you can share) is called id_rsa.pub. The private key (the one that you keep secure) is called id_rsa.
</p>
<p>You can add them to your DigitalOcean control panel to allow you to embed your SSH key into newly created droplets. This will allow your Ansible droplet to SSH into your new droplets immediately, without any other authentication.
</p>
<p>To do this, click on the "SSH Keys" link on the left-hand navigation menu. In the new screen, click on the "Add SSH Key" button in the top-right corner:
</p>
<p>Enter the name you want associated with this key into the top field. On your Ansible VPS instance, type this to get the contents of your public key:
</p>
<pre>
        #
        cat ~/.ssh/id_rsa.pub
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzmGgsqjSFuOBbjZB1sgquKpp3Ty+FgqoLrzjKbbk9VGOH6kM37aAhyxxmTQfe69lhYi/WCai+mrXOyY9IiQbUfZ4jsfPE9DS3zHhmnGiBWA7pedCTJ/Nhf06dmhAJIbExW3uDghbPbzbSA5Ihn1x0F5FXtSMDoFtyjcwUwJxc2z/kk9TKcFSl8qqf4IYBYE7c+EKaYRBjjDP4AQmiwjTPuipsmub7C0OGF0dTMatIa0lok6rwy91nmhCQV6polG0+Fsk4YrY8Yh5xz6wE0lOvc8BwP9nL0zsnw6Ey0MHV9BbMqtyD6x/fCurpIkMHJK4nv79rToSWA0AwoP/bJXh7 demo@ansible0
</pre>
<p>The string that is given back to you is what you need to paste in the second field in the DigitalOcean control panel:
</p>
<p>Click "Create SSH Key" to add your key to the control panel. Now, whenever you create a new droplet, you will be able to embed your public SSH key into the new server, allowing you to communicate with your Ansible instance. You just need to select the key in the "Add optional SSH Keys" section of the droplet creation process:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.4.2"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_4_2">Transfer an Existing SSH Key Pair to Ansible</a></h4>

<p>If you already have a SSH key pair that you are using to authenticate with your droplets, you can transfer the credentials to your new Ansible droplet instead of creating a new pair. This has the advantage of making it automatically work with any servers you have already configured to use the key.
</p>
<p>On the computer where you have configured SSH key authentication for your droplets, get the public key by typing:
</p>
<pre>
        #
        cat ~/.ssh/id_rsa.pub
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzmGgsqjSFuOBbjZB1sgquKpp3Ty+FgqoLrzjKbbk9VGOH6kM37aAhyxxmTQfe69lhYi/WCai+mrXOyY9IiQbUfZ4jsfPE9DS3zHhmnGiBWA7pedCTJ/Nhf06dmhAJIbExW3uDghbPbzbSA5Ihn1x0F5FXtSMDoFtyjcwUwJxc2z/kk9TKcFSl8qqf4IYBYE7c+EKaYRBjjDP4AQmiwjTPuipsmub7C0OGF0dTMatIa0lok6rwy91nmhCQV6polG0+Fsk4YrY8Yh5xz6wE0lOvc8BwP9nL0zsnw6Ey0MHV9BbMqtyD6x/fCurpIkMHJK4nv79rToSWA0AwoP/bJXh7 demo@ansible0
</pre>
<p>On your Ansible server, you need to create a hidden directory to store your keys. Call it .ssh so that the SSH program knows where to find it:
</p>
<pre>
        #
        mkdir ~/.ssh
</pre>
<p>We should lock access to this directory down so that only you can enter or write to it:
</p>
<pre>
        #
        chmod 700 ~/.ssh
</pre>
<p>Now, move into the directory and open a file called id_rsa.pub in your text editor:
</p>
<pre>
        #
        cd ~/.ssh
        nano id_rsa.pub
</pre>
<p>Paste the output of your public key from your home computer into this file:
</p>
<pre>
        #
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDzmGgsqjSFuOBbjZB1sgquKpp3Ty+FgqoLrzjKbbk9VGOH6kM37aAhyxxmTQfe69lhYi/WCai+mrXOyY9IiQbUfZ4jsfPE9DS3zHhmnGiBWA7pedCTJ/Nhf06dmhAJIbExW3uDghbPbzbSA5Ihn1x0F5FXtSMDoFtyjcwUwJxc2z/kk9TKcFSl8qqf4IYBYE7c+EKaYRBjjDP4AQmiwjTPuipsmub7C0OGF0dTMatIa0lok6rwy91nmhCQV6polG0+Fsk4YrY8Yh5xz6wE0lOvc8BwP9nL0zsnw6Ey0MHV9BbMqtyD6x/fCurpIkMHJK4nv79rToSWA0AwoP/bJXh7 demo@ansible0
</pre>
<p>Save and close the file. We will make sure that this file has the correct permissions by typing:
</p>
<pre>
        #
        chmod 644 id_rsa.pub
</pre>
<p>Now, back on your local computer that is configured for SSH key access, type:
</p>
<pre>
        #
        cat ~/.ssh/id_rsa
        -----BEGIN RSA PRIVATE KEY-----
        MIIEpgIBAAKCAQEA85hoLKo0hbjgW42QdbIKriqad08vhYKqC684ym25PVRjh+pD
        N+2gIcl8Zk0H3uvZYWIv1gmsfpq1zsmPSIkG1H2eI7HzxPQ0qMx4ZpxogVgO6XnQ
        kyfzYX9OnZoQCSGxMVt7g4IWz2820gOSIZ9cdBeRV7UjA6Bbco3MFMCcXNs/5JPU
        ynBUpfKqn+CGAWBO3PhCmmEQY4wz+AEJosI0z7oqbJrm/AtDhhdHUzGrSGtJaJOq
        . . .
        . . .
        cqsqOEzXAoGBAPMJJ8RrKUBuSjVNkzebst9sBgNadmaoQUoMHUDr8KpCZhWAoHB7
        1VKmq7VSphQSruI31qy2M88Uue1knC/nQr1bE1DITZgezETSsDqsAMBo8bqDN6TT
        qVJgG+TS9BRC+IowuzMVV5mzrfJjkrb+GG+xWSXrTLZMbeeTf+D0SfVo
        -----END RSA PRIVATE KEY-----
</pre>
<p>The output will be quite long.
</p>
<p>Back on your Ansible droplet, we need to create a new file in the ~/.ssh directory:
</p>
<pre>
        #
        nano id_rsa
</pre>
<p>Inside, paste the results of the previous command on your local computer:
</p>
<pre>
        #
        -----BEGIN RSA PRIVATE KEY-----
        MIIEpgIBAAKCAQEA85hoLKo0hbjgW42QdbIKriqad08vhYKqC684ym25PVRjh+pD
        N+2gIcl8Zk0H3uvZYWIv1gmsfpq1zsmPSIkG1H2eI7HzxPQ0qMx4ZpxogVgO6XnQ
        kyfzYX9OnZoQCSGxMVt7g4IWz2820gOSIZ9cdBeRV7UjA6Bbco3MFMCcXNs/5JPU
        ynBUpfKqn+CGAWBO3PhCmmEQY4wz+AEJosI0z7oqbJrm/AtDhhdHUzGrSGtJaJOq
        . . .
        . . .
        cqsqOEzXAoGBAPMJJ8RrKUBuSjVNkzebst9sBgNadmaoQUoMHUDr8KpCZhWAoHB7
        1VKmq7VSphQSruI31qy2M88Uue1knC/nQr1bE1DITZgezETSsDqsAMBo8bqDN6TT
        qVJgG+TS9BRC+IowuzMVV5mzrfJjkrb+GG+xWSXrTLZMbeeTf+D0SfVo
        -----END RSA PRIVATE KEY-----
</pre>
<p>Make sure that you include the first and last marker lines. They are required in order for the key file to be valid. Save and close the file.
</p>
<p>We need to change the permissions to keep this file secure:
</p>
<pre>
        #
        chmod 600 id_rsa
</pre>
<p>At this point, Ansible will be able to use these SSH keys to communicate with any servers that have the key embedded.
</p>
<dl>
  <dt>MY NOTE</dt>
<dd>When testing with a Vagrant box, I just copied the ssh public key from the host machine to the ".ssh/authorized_keys" file in the Vagrant box, and restarted the ssh daemon. Then I can connect with the command below.
</dd></dl>
<pre>
        #
        $ ssh vagrant@127.0.0.1 -p2222
</pre>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.5"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_5">Configuring Ansible Hosts</a></h3>

<p>Ansible keeps track of all of the servers that it knows about through a "hosts" file. We need to set up this file first before we can begin to communicate with our other computers.
</p>
<p>Open the file with root privileges like this:
</p>
<pre>
        #
        sudo nano /etc/ansible/hosts
</pre>
<p>You will see a file that has a lot of example configurations, none of which will actually work for us since these hosts are made up. So to start, let's comment out all of the lines in this file by adding a "#" before each line.
</p>
<p>We will keep these examples in the file to help us with configuration if we want to implement more complex scenarios in the future.
</p>
<p>Once all of the lines are commented out, we can begin adding our actual hosts.
</p>
<p>The hosts file is fairly flexible and can be configured in a few different ways. The syntax we are going to use though looks something like this:
</p>
<pre>
        #
        [group_name]
        alias ansible_ssh_host=server_ip_address
</pre>
<p>The group_name is an organizational tag that lets you refer to any servers listed under it with one word. The alias is just a name to refer to that server.
</p>
<p>So in our scenario, we are imagining that we have three servers we are going to control with Ansible. These servers are accessible from the Ansible droplet by typing:
</p>
<pre>
        #
        ssh root@server_ip_address
</pre>
<p>You should not be prompted for a password if you have set this up correctly. We will assume that our droplets' IP addresses are <a href="telnet://192.0.2.1">192.0.2.1</a>, <a href="telnet://192.0.2.2">192.0.2.2</a>, and <a href="telnet://192.0.2.3">192.0.2.3</a>. We will set this up so that we can refer to these individually as host1, host2, and host3, or as a group as droplets.
</p>
<p>This is the block that we should add to our hosts file to accomplish this:
</p>
<pre>
        #
        [droplets]
        host1 ansible_ssh_host=<a href="telnet://192.0.2.1">192.0.2.1</a>
        host2 ansible_ssh_host=<a href="telnet://192.0.2.2">192.0.2.2</a>
        host3 ansible_ssh_host=<a href="telnet://192.0.2.3">192.0.2.3</a>
</pre>
<dl>
  <dt>MY NOTE</dt>
<dd>This is what I did on my test host machine, so that I could reach the Vagrant box I created previously, and where I copied the public ssh key, into the authorized_keys file on the Vagrant box.
</dd></dl>
<pre>
        #
        [test_group]
        test_machine ansible_host=<a href="telnet://127.0.0.1">127.0.0.1</a> ansible_port=2222 ansible_user=vagrant
</pre>
<p>Relevant Ansible docs for the inventory file.
<a href="http://docs.ansible.com/ansible/intro_inventory.html">http://docs.ansible.com/ansible/intro_inventory.html</a>
</p>
<pre>
        #
        $ ansible all -m ping
        test_machine | SUCCESS =&gt; {
            "changed": false, 
            "ping": "pong"
        }
</pre>
<p>Hosts can be in multiple groups and groups can configure parameters for all of their members. Let's try this out now.
</p>
<p>With our current settings, if we tried to connect to any of these hosts with Ansible, the command would fail (assuming you are not operating as the root user). This is because your SSH key is embedded for the root user on the remote systems and Ansible will by default try to connect as your current user. A connection attempt will get this error:
</p>
<pre>
        #
        host1 | FAILED =&gt; SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue
</pre>
<p>In my Ansible computer, I'm using a user called demo. Ansible will try to connect to each host with ssh demo@server. This will not work if the demo user is not on the remote system.
</p>
<p>We can create a file that tells all of the servers in the "droplets" group to connect using the root user.
</p>
<p>To do this, we will create a directory in the Ansible configuration structure called group_vars. Within this folder, we can create YAML-formatted files for each group we want to configure:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.5.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_5_1">/etc/ansible/group_vars</a></h4>

<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.5.2"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_5_2">/etc/ansible/group_vars/droplet</a></h4>

<pre>
        #
        sudo mkdir /etc/ansible/group_vars
        sudo nano /etc/ansible/group_vars/droplets
</pre>
<p>We can put our configuration in here. YAML files start with "---", so make sure you don't forget that part.
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.5.3"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_5_3">ansible_ssh_user: root</a></h4>

<pre>
        #
                #
        ---
        ansible_ssh_user: root
</pre>
<p>Save and close this file when you are finished.
</p>
<p>If you want to specify configuration details for every server, regardless of group association, you can put those details in a file at: 
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.5.4"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_5_4">/etc/ansible/group_vars/all</a></h4>

<pre>
        #
        /etc/ansible/group_vars/all 
</pre>
<p>Individual hosts can be configured by creating files under a directory at 
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.5.5"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_5_5">/etc/ansible/host_vars</a></h4>

<pre>
        #
        /etc/ansible/host_vars
</pre>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.6"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_6">Using Simple Ansible Commands</a></h3>

<p>Now that we have our hosts set up and enough configuration details to allow us to successfully connect to our hosts, we can try out our very first command.
</p>
<p>Ping all of the servers you configured by typing:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.6.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_6_1">$ ansible -m ping all</a></h4>

<pre>
        #
                host1 | success &gt;&gt; {
                        "changed": false,
                        "ping": "pong"
                }

                host3 | success &gt;&gt; {
                        "changed": false,
                        "ping": "pong"
                }

                host2 | success &gt;&gt; {
                        "changed": false,
                        "ping": "pong"
                }
</pre>
<p>This is a basic test to make sure that Ansible has a connection to all of its hosts.
</p>
<p>The "all" means all hosts. We could just as easily specify a group:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.6.2"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_6_2">$ ansible -m ping droplets</a></h4>

<p>We could also specify an individual host:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.6.3"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_6_3">$ ansible -m ping host1</a></h4>

<p>We can specify multiple hosts by separating them with colons:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.6.4"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_6_4">$ ansible -m ping host1:host2</a></h4>

<p>The -m ping portion of the command is an instruction to Ansible to use the "ping" module. These are basically commands that you can run on your remote hosts. The ping module operates in many ways like the normal ping utility in Linux, but instead it checks for Ansible connectivity.
</p>
<p>The ping module doesn't really take any arguments, but we can try another command to see how that works. We pass arguments into a script by typing -a.
</p>
<p>The "shell" module lets us send a terminal command to the remote host and retrieve the results. For instance, to find out the memory usage on our host1 machine, we could use:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.6.5"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_6_5">$ ansible -m shell -a 'free -m' host1</a></h4>

<pre>
                #
                host1 | success | rc=0 &gt;&gt;
                                         total       used       free     shared    buffers     cached
                Mem:          3954        227       3726          0         14         93
                -/+ buffers/cache:        119       3834
                Swap:            0          0          0
</pre>
<p>Conclusion
</p>
<p>By now, you should have your Ansible server configured to communicate with the servers that you would like to control. We have verified that Ansible can communicate with each host and we have used the ansible command to execute simple tasks remotely.
</p>
<p>Although this is useful, we have not covered the most powerful feature of Ansible in this article: Playbooks. We have set up a great foundation for working with our servers through Ansible, but the heavy lifting will be done in a future article, when we cover how to use Playbooks to automate configuration of your remote computers.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.1.7"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_1_7">Comments</a></h3>

<p>June 1, 2014
</p>
<p>In the section "Using Simple Ansible Commands," you say, "We can specify multiple hosts by separating them with colons." More precisely you can do the union, intersection, or difference of the machines or groups listed. The Ansible documents on this are a bit weak, <a href="http://docs.ansible.com/intro_patterns.html">http://docs.ansible.com/intro_patterns.html</a> but I learned it from <a href="http://zaiste.net/2014/05/ansible_101/">http://zaiste.net/2014/05/ansible_101/</a> . Look at the middle of the page for the section named Usage. "Groups can be combined A:B designates the union of groups A and B A:&amp;B designates the intersection of groups A and B A:!B designates the difference, all from A without those in B"
</p>
<p>October 25, 2014
</p>
<p>Good introductory tutorial! I think it would be interesting to point that connecting and running the tasks as root might not be the best practice on a daily basis, as all commands will be executed as root.
</p>
<h2><!-- #BeginTocAnchorNameBegin --><a name="h-1.2"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2">Title: how-to-create-ansible-playbooks-to-automate-system-configuration-on-ubuntu</a></h2>
<p>Source: <a href="https://www.digitalocean.com/community/tutorials/how-to-create-ansible-playbooks-to-automate-system-configuration-on-ubuntu">https://www.digitalocean.com/community/tutorials/how-to-create-ansible-playbooks-to-automate-system-configuration-on-ubuntu</a>
</p>
<p>Added: Thu Dec  1 19:52:05 CET 2016<br/>
Created: PostedFebruary 7, 2014
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_1">Introduction</a></h3>

<p>Ansible is an easy configuration management system that can be used to automate and organize your system configuration tasks for a large network of computers. While some other configuration management systems require many different packages to be installed on the server and client systems, with Ansible, you only need to install a server component and have SSH access to the client machines.
</p>
<p>In a previous guide, we discussed how to install the Ansible software and learn basic commands. In this guide, we will discuss Ansible playbooks, which are Ansible's way of creating automated scripts to configure client computers.
</p>
<p>We will assume that you have a configured Ansible server and a few clients, just as we left off in the last tutorial. In our guide, the server is a Ubuntu 12.04 machine, and the clients that we are going to be configuring are also Ubuntu 12.04 machines, for ease of explanation.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.2"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_2">What are Ansible Playbooks?</a></h3>

<p>Ansible playbooks are a way to send commands to remote computers in a scripted way. Instead of using Ansible commands individually to remotely configure computers from the command line, you can configure entire complex environments by passing a script to one or more systems.
</p>
<p>Ansible playbooks are written in the YAML data serialization format. If you don't know what a data serialization format is, think of it as a way to translate a programmatic data structure (lists, arrays, dictionaries, etc) into a format that can be easily stored to disk. The file can then be used to recreate the structure at a later point. JSON is another popular data serialization format, but YAML is much easier to read.
</p>
<p>Each playbook contains one or more plays, which map hosts to a certain function. Ansible does this through something called tasks, which are basically module calls.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.3"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_3">Exploring a Basic Playbook</a></h3>

<p>Let's look at a basic playbook:
</p>
<pre>
                #
                #
                ---
                - hosts: droplets
                  tasks:
                        - name: Installs nginx web server
                          apt: pkg=nginx state=installed update_cache=true
                          notify:
                                - start nginx

                  handlers:
                        - name: start nginx
                          service: name=nginx state=started
</pre>
<p>Let's break this down in sections so we can understand how these files are built and what each piece means.
</p>
<p>The file starts with:
</p>
<pre>
                #
                #
                ---
</pre>
<p>This is a requirement for YAML to interpret the file as a proper document. YAML allows multiple "documents" to exist in one file, each separated by ---, but Ansible only wants one per file, so this should only be present at the top of the file.
</p>
<p>YAML is very sensitive to white-space, and uses that to group different pieces of information together. You should use only spaces and not tabs and you must use consistent spacing for your file to be read correctly. Items at the same level of indentation are considered sibling elements.
</p>
<p>Items that begin with a - are considered list items. Items that have the format of key: value operate as hashes or dictionaries. That's pretty much all there is to basic YAML.
</p>
<p>YAML documents basically define a hierarchical tree structure with the containing elements further to the left.
</p>
<p>On the second line, we have this:
</p>
<pre>
                #
                #
                ---
                - hosts: droplets
</pre>
<p>This is a list item in YAML as we learned above, but since it is at the left-most level, it is also an Ansible "play". Plays are basically groups of tasks that are performed on a certain set of hosts to allow them to fulfill the function you want to assign to them. Each play must specify a host or group of hosts, as we do here.
</p>
<p>Next, we have a set of tasks:
</p>
<pre>
                #
                #
                ---
                - hosts: droplets
                  tasks:
                        - name: Installs nginx web server
                          apt: pkg=nginx state=installed update_cache=true
                          notify:
                                - start nginx
</pre>
<p>At the top level, we have "tasks:" at the same level as "hosts:". This contains a list (because it starts with a "-") which contains key-value pairs.
</p>
<p>The first one, "name", is more of a description than a name. You can call this whatever you would like.
</p>
<p>The next key is "apt". This is a reference to an Ansible module, just like when we use the ansible command and type something like:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.3.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_3_1">$ ansible -m apt -a 'whatever' all</a></h4>

<p>This module allows us to specify a package and the state that it should be in, which is "installed" in our case. The update-cache=true part tells our remote machine to update its package cache (apt-get update) prior to installing the software.
</p>
<p>The "notify" item contains a list with one item, which is called "start nginx". This is not an internal Ansible command, it is a reference to a handler, which can perform certain functions when it is called from within a task. We will define the "start nginx" handler below.
</p>
<pre>
                #
                #
                ---
                - hosts: droplets
                  tasks:
                        - name: Installs nginx web server
                          apt: pkg=nginx state=installed update_cache=true
                          notify:
                                - start nginx

                  handlers:
                        - name: start nginx
                          service: name=nginx state=started
</pre>
<p>The "handlers" section exists at the same level as the "hosts" and "tasks". Handlers are just like tasks, but they only run when they have been told by a task that changes have occurred on the client system.
</p>
<p>For instance, we have a handler here that starts the Nginx service after the package is installed. The handler is not called unless the "Installs nginx web server" task results in changes to the system, meaning that the package had to be installed and wasn't already there.
</p>
<p>We can save this playbook into a file called something like "nginx.yml".
</p>
<p>Just for some context, if you were to write this same file in JSON, it might look something like this:
</p>
<pre>
                #
                #
                [
                        {
                                "hosts": "droplets",
                                "tasks": [
                                        {
                                                "name": "Installs nginx web server",
                                                "apt": "pkg=nginx state=installed update_cache=true",
                                                "notify": [
                                                        "start nginx"
                                                ]
                                        }
                                ],
                                "handlers": [
                                        {
                                                "name": "start nginx",
                                                "service": "name=nginx state=started"
                                        }
                                ]
                        }
                ]
</pre>
<p>As you can see, YAML is much more compact and most people would say more readable.
</p>
<dl>
  <dt>MY NOTE</dt>
<dd>Two perl scripts, first just a proof of concept.
Second works on the example playbook given above, and translates it to JSON, but it had problems with tabs, and so i had to remove tabs, and use spaces instead as indentation in YAML.
</dd></dl>
<p>First script.
</p>
<pre>
                #
                $ cat yaml2json.pl
                #!/usr/bin/env perl
                # Name:
                # Version:

                use strict;
                use warnings;

                use YAML;
                use JSON;

                # Load a YAML hash containing a scalar ref as a value.
                my ($hashref) = Load(&lt;&lt;'END_YAML');
                ---
                bar: ref
                foo: 1
                END_YAML

                use Data::Dump;
                dd $hashref;

                my $json_text = encode_json($hashref);
</pre>
<dl>
  <dt>Output</dt>
<dd>
</dd></dl>
<pre>
                #
                $ perl yaml2json.pl
                { bar =&gt; "ref", foo =&gt; 1 }
</pre>
<p>Second script.
</p>
<pre>
                #
                $ cat yaml2json_2.pl
                #!/usr/bin/env perl
                # Name:
                # Version:

                use strict;
                use warnings;

                use YAML;
                use JSON;

                my $slurped;

                {
                local $/ = undef;
                $slurped = &lt;DATA&gt;;
                }

                # Load a YAML hash containing a scalar ref as a value.
                my ($hashref) = Load($slurped);

                use Data::Dump;
                dd $hashref;

                my $json_text = encode_json($hashref);
                __DATA__
                ---
                - hosts: droplets
                  tasks:
                        - name: Installs nginx web server
                          apt: pkg=nginx state=installed update_cache=true
                          notify:
                                - start nginx

                  handlers:
                        - name: start nginx
                          service: name=nginx state=started
</pre>
<dl>
  <dt>Output</dt>
<dd>
                
</dd></dl>
<pre>
                #
                $ perl yaml2json_2.pl
                [
                  {
                        handlers =&gt; [
                                                  { name =&gt; "start nginx", service =&gt; "name=nginx state=started" },
                                                ],
                        hosts    =&gt; "droplets",
                        tasks    =&gt; [
                                                  {
                                                        apt =&gt; "pkg=nginx state=installed update_cache=true",
                                                        name =&gt; "Installs nginx web server",
                                                        notify =&gt; ["start nginx"],
                                                  },
                                                ],
                  },
                ]
</pre>
<p>The source of the first script.<br/>
<a href="http://stackoverflow.com/questions/25633657/perl-yaml-to-json#25633718">http://stackoverflow.com/questions/25633657/perl-yaml-to-json#25633718</a>
</p>
<p>Slurp whole YAML into scalar variable, found useful example on page below.
<a href="https://perlmaven.com/slurp">https://perlmaven.com/slurp</a>
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.4"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_4">Running an Ansible Playbook</a></h3>

<p>Once you have a playbook built, you can call it easily using this format:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.4.1"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_4_1">$ ansible-playbook playbook.yml</a></h4>

<p>For instance, if we wanted to install and start up Nginx on all of our droplets, we could issue this command:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.4.2"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_4_2">$ ansible-playbook nginx.yml</a></h4>

<p>Since the playbook itself specifies the hosts that it should run against (namely, the "droplets" group we created in the last tutorial), we do not have to specify a host to run against.
</p>
<p>However, if we would like to filter the host list to only apply to one of those hosts, we can add a flag to specify a subset of the hosts in the file:
</p>
<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.4.3"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_4_3">$ ansible-playbook -l host_subset playbook.yml</a></h4>

<h4><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.4.4"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_4_4">$ ansible-playbook -l host3 nginx.yml</a></h4>

<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.5"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_5">Adding Features to the Playbook</a></h3>

<p>Right now our playbook looks like this:
</p>
<pre>
                #
                #
                ---
                - hosts: droplets
                  tasks:
                        - name: Installs nginx web server
                          apt: pkg=nginx state=installed update_cache=true
                          notify:
                                - start nginx

                  handlers:
                        - name: start nginx
                          service: name=nginx state=started
</pre>
<p>It is simple and it works, but all it is doing is installing a piece of software and starting it. That's not very beneficial by itself.
</p>
<p>We can start to expand the functionality by adding tasks to our playbook.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.6"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_6">Add a Default Index File</a></h3>

<p>We can tell it to transfer a file from our Ansible server onto the host by adding some lines like this:
</p>
<pre>
                #
                #
                ---
                - hosts: droplets
                  tasks:
                        - name: Installs nginx web server
                          apt: pkg=nginx state=installed update_cache=true
                          notify:
                                - start nginx

                        - name: Upload default index.html for host
                          copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644

                  handlers:
                        - name: start nginx
                          service: name=nginx state=started
</pre>
<p>We can then make a directory called static_files in our current directory and place an index.html file inside.
</p>
<pre>
                #
                mkdir static_files
                nano static_files/index.html
</pre>
<p>Inside of this file, let's just create a basic html structure:
</p>
<pre>
                #
                &lt;html&gt;
                  &lt;head&gt;
                        &lt;title&gt;This is a sample page&lt;/title&gt;
                  &lt;/head&gt;
                  &lt;body&gt;
                        &lt;h1&gt;Here is a heading!&lt;/h1&gt;
                        &lt;p&gt;Here is a regular paragraph.  Wow!&lt;/p&gt;
                  &lt;/body&gt;
                &lt;/html&gt;
</pre>
<p>Save and close the file.
</p>
<p>Now, when we re-run the playbook, Ansible will check each task. It will see that Nginx is already installed on the host, so it will leave it be. It will see the new task section and replace the default index.html file with the one from our server.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.7"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_7">Registering Results</a></h3>

<p>When you are installing and configuring services manually, it is almost always necessary to know whether your actions were successful or not. We can cook this functionality into our playbooks by using "register".
</p>
<p>For each task, we can optionally register its result (failure or success) in a variable that we can check later on.
</p>
<p>When using this functionality, we also have to tell Ansible to ignore errors for that task, since normally it aborts the playbook execution for that host if any trouble happens.
</p>
<p>So, if we want to check whether a task has failed or not to decide on subsequent steps, we can use the register functionality.
</p>
<p>For instance, we could tell our playbook to upload an index.php file if it exists. If that task fails, we could instead try to upload an index.html file. We will check for the failure condition in the other task because we only want to upload the HTML file if the PHP file fails:
</p>
<pre>
                #
                #
                ---
                - hosts: droplets
                  tasks:
                        - name: Installs nginx web server
                          apt: pkg=nginx state=installed update_cache=true
                          notify:
                                - start nginx

                        - name: Upload default index.php for host
                          copy: src=static_files/index.php dest=/usr/share/nginx/www/ mode=0644
                          register: php
                          ignore_errors: True

                        - name: Remove index.html for host
                          command: rm /usr/share/nginx/www/index.html
                          when: php|success

                        - name: Upload default index.html for host
                          copy: src=static_files/index.html dest=/usr/share/nginx/www/ mode=0644
                          when: php|failed

                  handlers:
                        - name: start nginx
                          service: name=nginx state=started
</pre>
<p>Note: We have not configured our host to handle PHP files at this time, so even if you did upload a PHP file, it would not be processed correctly.
</p>
<p>This new version tries to upload a PHP index file to the host. It registers the success of the operation into a variable called "php".
</p>
<p>If this operation was successful, the task to remove the index.html file is run next.
</p>
<p>If the operation failed, the index.html file is uploaded instead.
</p>
<p>Conclusion
</p>
<p>Now, you should have a good handle on how to automate complex tasks using Ansible. This is a basic example of how you can begin to build your configuration library.
</p>
<p>Combining host and group definitions as we learned about in the first tutorial, and using available variables to fill in information, we can begin to put together complex computer systems that interact with each other. In a future article, we will discuss how to implement variables into our playbooks and create roles to help manage complex tasks.
</p>
<h3><!-- #BeginTocAnchorNameBegin --><a name="h-1.2.8"></a><!-- #EndTocAnchorNameBegin --><a name="section_1_2_8">Comments</a></h3>

<p>March 17, 2014
</p>
<p>According to the ansible docs(<a href="http://docs.ansible.com/apt_module.html">http://docs.ansible.com/apt_module.html</a>) the command equivalent to apt-get update is actually update_cache=yes rather than update_cache=true Otherwise, I like the tutorial.
</p>

</body>
</html>
