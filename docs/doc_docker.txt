Docker Documentation
***

Title: how-to-use-the-digitalocean-docker-application
===
Source: https://www.digitalocean.com/community/tutorials/how-to-use-the-digitalocean-docker-application

Added: Wed Nov  2 09:53:53 CET 2016
Created: PostedSeptember 20, 2013


$ docker run ubuntu echo "Hello World"
+++
-docker will search for the 'ubuntu' image on your local machine, if it doesn't find it it will pull the image from the 'Docker Central Registry'

-docker will run a container from an image named "ubuntu" (which contains the whole "ubuntu" root file system ~180MB)

-docker will execute 'echo "Hello World"' in the shell (in the container) and exit


$ docker images
+++
-list docker images which have been downloaded/cached or created on your local machine


$ docker ps -a
+++
-lists all containers, even those which have exited (are not running any more)

-those which have exited are visible because the writable file system layer used by the temporary container (for example the one mentioned above, which echo-ed "Hello World" and exited) is still around


$ docker rm
+++
-remove a container


$ docker rmi
+++
-remove an image


$ docker version
+++
-shows currently installed docker client/server version



Title: how-to-install-and-use-docker-getting-started
===
Source: https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-getting-started

Added: Wed Nov  2 10:39:28 CET 2016
Created: PostedDecember 11, 2013


Docker is here to offer you an efficient, speedy way to port applications across systems and machines. It is light and lean, allowing you to quickly contain applications and run them within their own secure environments (via Linux Containers: LXC). 

Whether it be from your development machine to a remote server for production, or packaging everything for use elsewhere, it is always a challenge when it comes to porting your application stack together with its dependencies and getting it to run without hiccups. In fact, the challenge is immense and solutions so far have not really proved successful for the masses.

In a nutshell, docker as a project offers you the complete set of higher-level tools to carry everything that forms an application across systems and machines - virtual or physical - and brings along loads more of great benefits with it.

Docker achieves its robust application (and therefore, process and resource) containment via Linux Containers (e.g. namespaces and other kernel features). Its further capabilities come from a project's own parts and components, which extract all the complexity of working with lower-level linux tools/APIs used for system and application management with regards to securely containing processes.

Main Docker Parts:
+++

- docker daemon: used to manage docker (LXC) containers on the host it runs
- docker CLI: used to command and communicate with the docker daemon
- docker image index: a repository (public or private) for docker images

Main Docker Elements:
+++

- docker containers: directories containing everything-your-application
- docker images: snapshots of containers or base OS (e.g. Ubuntu) images
- Dockerfiles: scripts automating the building process of images


Docker Containers:
+++

The entire procedure of porting applications using docker relies solely on the shipment of containers.

Docker containers are basically directories which can be packed (e.g. tar-archived) like any other, then shared and run across various different machines and platforms (hosts). The only dependency is having the hosts tuned to run the containers (i.e. have docker installed). Containment here is obtained via Linux Containers (LXC).

Linux Containers can be defined as a combination various kernel-level features (i.e. things that Linux-kernel can do) which allow management of applications (and resources they use) contained within their own environment. By making use of certain features (e.g. namespaces, chroots, cgroups and SELinux profiles), the LXC contains application processes and helps with their management through limiting resources, not allowing reach beyond their own file-system (access to the parent's namespace) etc.

Docker with its containers makes use of LXC, however, also brings along much more.

Being based and depending on LXC, from a technical aspect, these containers are like a directory (but a shaped and formatted one). This allows portability and gradual builds of containers.

Each container is layered like an onion and each action taken within a container consists of putting another block (which actually translates to a simple change within the file system) on top of the previous one. And various tools and configurations make this set-up work in a harmonious way altogether (e.g. union file-system/aufs).

What this way of having containers allows is the extreme benefit of easily launching and creating new containers and images, which are thus kept lightweight (thanks to gradual and layered way they are built). Since everything is based on the file-system, taking snapshots and performing roll-backs in time are cheap (i.e. very easily done / not heavy on resources), much like version control systems (VCS).

Each docker container starts from a docker image which forms the base for other applications and layers to come.


Docker Images:
+++

Docker images constitute the base of docker containers from which everything starts to form. They are very similar to default operating-system disk images which are used to run applications on servers or desktop computers.

Having these images (e.g. Ubuntu base) allow seamless portability across systems. They make a solid, consistent and dependable base with everything that is needed to run the applications. When everything is self-contained and the risk of system-level updates or modifications are eliminated, the container becomes immune to external exposures which could put it out of order - preventing the dependency hell.

As more layers (tools, applications etc.) are added on top of the base, new images can be formed by committing these changes. When a new container gets created from a saved (i.e. committed) image, things continue from where they left off. And the union file system, brings all the layers together as a single entity when you work with a container.

These base images can be explicitly stated when working with the docker CLI to directly create a new container or they might be specified inside a Dockerfile for automated image building.


Dockerfiles
+++

Dockerfiles are scripts containing a successive series of instructions, directions, and commands which are to be executed to form a new docker image. Each command executed translates to a new layer of the onion, forming the end product. They basically replace the process of doing everything manually and repeatedly. When a Dockerfile is finished executing, you end up having formed an image, which then you use to start (i.e. create) a new container.


$ docker
---
-lists all available docker commands

$ docker info
---
-shows system-wide information on docker, among other info

- total number of created containers, which of them are Running/Paused/Stopped
- number of locally available images
- storage driver, i.e. aufs
- root directory, i.e. /var/lib/docker/aufs
- Network, i.e. host null overlay bridge
- Docker Root Dir, i.e. /var/lib/docker


Working with Images:
+++

As we have discussed at length, the key to start working with any docker container is using images. There are many freely available images shared across docker image index and the CLI allows simple access to query the image repository and to download new ones.

When you are ready, you can also share your image there as well. See the section on "push" further down for details.


$ docker search ubuntu
---
-searching for a docker image, in the above example, the image we are searching for is named ubuntu

-this search will provide you a list of all available images matching the query 'ubuntu'


$ docker pull ubuntu
---
-either when you are building / creating a container or before you do, you will need to have an image present at the host machine where the containers will exist. In order to download images (perhaps following "search") you can execute pull to get one


$ docker images
---
-all the images on your system, including the ones you have created by committing (see below for details), can be listed using "images"


$ docker commit 8dbd9e392a96 my_img
---
-as you work with a container and continue to perform actions on it (e.g. download and install software, configure files etc.), to have it keep its state, you need to "commit" 

-committing makes sure that everything continues from where they left next time you use one (i.e. an image)


$ docker push my_username/my_first_image
---
-although it is a bit early at this moment - in our article, when you have created your own container which you would like to share with the rest of the world, you can use push to have your image listed in the index where everybody can download and use

-please remember to "commit" all your changes

-note: You need to sign-up at index.docker.io to push images to docker index


Working with Containers:
+++

When you "run" any process using an image, in return, you will have a container. When the process is not actively running, this container will be a non-running container. Nonetheless, all of them will reside on your system until you remove them via rm command.

$ docker ps
---
-list all running containers

$ docker ps -a
---
-list of both running and non-running ones

$ docker ps -l
---
-list the last run container
-shows only the latest created container, include non-running ones


Creating a New Container:
+++

It is currently not possible to create a container without running anything (i.e. commands). To create a new container, you need to use a base image and specify a command to run.

$ docker run my_img echo "hello"
---
-usage: docker run [image name] [command to run]

$ docker run --name my_cont_1 my_img echo "hello"
---
-to name a container instead of having long IDs

-usage: sudo docker run -name [name] [image name] [command to run]

Running a container:
+++

$ docker run c629b7d70666
---
-usage: docker run [container ID]
-when you create a container and it stops (either due to its process ending or you stopping it explicitly), you can use 'run' to get the container working again with the same command used to create it.

Stopping a container:
+++

$ docker stop c629b7d70666
---
-usage: docker stop [container ID]
-to stop a container's process from running

Saving (committing) a container:
+++

If you would like to save the progress and changes you made with a container, you can use "commit" as explained above to save it as an image.

    This command turns your container to an image.

Remember that with docker, commits are cheap. Do not hesitate to use them to create images to save your progress with a container or to roll back when you need (e.g. like snapshots in time).

Removing / Deleting a container
+++

$ docker rm c629b7d70666
---
-usage: docker rm [container ID]

-using the ID of a container, you can delete one with rm


Title: docker-explained-using-dockerfiles-to-automate-building-of-images
===
Source: https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images

Added: Thu Nov  3 13:39:08 CET 2016
Created: PostedDecember 13, 2013

Introduction
+++

Docker containers are created by using [base] images. An image can be basic, with nothing but the operating-system fundamentals, or it can consist of a sophisticated pre-built application stack ready for launch.

When building your images with docker, each action taken (i.e. a command executed such as apt-get install) forms a new layer on top of the previous one. These base images then can be used to create new containers.

In this DigitalOcean article, we will see about automating this process as much as possible, as well as demonstrate the best practices and methods to make most of docker and containers via Dockerfiles: scripts to build containers, step-by-step, layer-by-layer, automatically from a source (base) image.


Docker in Brief
+++

The docker project offers higher-level tools which work together, built on top of some Linux kernel features. The goal is to help developers and system administrators port applications. - with all of their dependencies conjointly - and get them running across systems and machines headache free.

Docker achieves this by creating safe, LXC (i.e. Linux Containers) based environments for applications called “docker containers”. These containers are created using docker images, which can be built either by executing commands manually or automatically through Dockerfiles.


Dockerfiles
+++

Each Dockerfile is a script, composed of various commands (instructions) and arguments listed successively to automatically perform actions on a base image in order to create (or form) a new one. They are used for organizing things and greatly help with deployments by simplifying the process start-to-finish.

Dockerfiles begin with defining an image FROM which the build process starts. Followed by various other methods, commands and arguments (or conditions), in return, provide a new image which is to be used for creating docker containers.

They can be used by providing a Dockerfile's content - in various ways - to the docker daemon to build an image.


Dockerfile Syntax Example
+++

Dockerfile syntax consists of two kind of main line blocks: comments and commands + arguments.

# Line blocks used for commenting
command argument argument ..

A Simple Example

        # Print "Hello docker!"
        RUN echo "Hello docker!"

Dockerfiles use simple, clean, and clear syntax which makes them strikingly easy to create and use. They are designed to be self explanatory, especially because they allow commenting just like a good and properly written application source-code. 


Dockerfile Commands/Instructions
+++

Currently there are about a dozen different set of commands which Dockerfiles can contain to have docker build an image. In this section, we will go over all of them, individually, before working on a Dockerfile example.

Note. As explained in the previous section (Dockerfile Syntax), all these commands are to be listed (i.e. written) successively, inside a single plain text file (i.e. Dockerfile), in the order you would like them performed (i.e. executed) by the docker daemon to build an image. However, some of these commands (e.g. MAINTAINER) can be placed anywhere you seem fit (but always after FROM command), as they do not constitute of any execution but rather value of a definition (i.e. just some additional information).


add
---

The ADD command gets two arguments: a source and a destination. It basically copies the files from the source on the host into the container's own filesystem at the set destination. If, however, the source is a URL (e.g. http://github.com/user/file/), then the contents of the URL are downloaded and placed at the destination.

Example

        # Usage, ADD [source directory or URL] [destination directory]
        ADD /my_app_folder /my_app_folder


cmd
---

The command CMD, similarly to RUN, can be used for executing a specific command. However, unlike RUN it is not executed during build, #but when a container is instantiated# using the image being built. Therefore, it should be considered as an initial, default command that gets executed (i.e. run) with the creation of containers based on the image.

To clarify. an example for CMD would be running an application upon creation of a container which is already installed using RUN (e.g. RUN apt-get install …) inside the image. This default application execution command that is set with CMD becomes the default and replaces any command which is passed during the creation.

Example

        # Usage,  CMD application "argument", "argument", ..
        CMD "echo" "Hello docker!"


entrypoint
---

ENTRYPOINT argument sets the concrete default application that is used every time a container is instantiated/created using the image. For example, if you have installed a specific application inside an image and you will use this image to only run that application, you can state it with ENTRYPOINT and whenever a container is created from that image, your application will be the target.

If you couple ENTRYPOINT with CMD, you can remove "application" from CMD and just leave "arguments" which will be passed to the ENTRYPOINT.

Example:

        # Usage: ENTRYPOINT application "argument", "argument", ..
        # Remember: arguments are optional. They can be provided by CMD
        #           or during the creation of a container. 
        ENTRYPOINT echo

        # Usage example with CMD:
        # Arguments set with CMD can be overridden during *run*
        CMD "Hello docker!"
        ENTRYPOINT echo  


env
---

The ENV command is used to set the environment variables (one or more). These variables consist of “key value” pairs which can be accessed within the container by scripts and applications alike. This functionality of docker offers an enormous amount of flexibility for running programs.

Example:

        #Usage: ENV key value
        ENV SERVER_WORKS 4


expose
---

The EXPOSE command is used to associate a specified port to enable networking between the running process inside the container and the outside world (i.e. the host).

Example:

        #Usage: EXPOSE [port]
        EXPOSE 8080


from
---

FROM directive is probably the most crucial amongst all others for Dockerfiles. It defines the base image to use to start the build process. It can be any image, including the ones you have created previously. If a FROM image is not found on the host, docker will try to find it (and download) from the docker image index. It needs to be the first command declared inside a Dockerfile.

Example:

        # Usage: FROM [image name]
        FROM ubuntu


maintainer
---

One of the commands that can be set anywhere in the file - although it would be better if it was declared on top - is MAINTAINER. This non-executing command declares the author, hence setting the author field of the images. It should come nonetheless after FROM.

Example:

        # Usage: MAINTAINER [name]
        MAINTAINER authors_name


run
---

The RUN command is the central executing directive for Dockerfiles. It takes a command as its argument and runs it to form/create the image. Unlike CMD, #it actually is used to build the image# (forming another layer on top of the previous one which is committed).

Example:

        # Usage: RUN [command]
        RUN aptitude install -y riak


user
---

The USER directive is used to set the UID (or username) which is to run the container based on the image being built.

Example:

        # Usage: USER [UID]
        USER 751


volume
---

The VOLUME command is used to enable access from your container to a directory on the host machine (i.e. mounting it).

Example:

        # Usage: VOLUME ["/dir_1", "/dir_2" ..]
        VOLUME ["/my_files"]


workdir
---

The WORKDIR directive is used to set where the command defined with CMD is to be executed.

Example:

        # Usage: WORKDIR /path
        WORKDIR ~/


How to Use Dockerfiles
+++

Using the Dockerfiles is as simple as having the docker daemon run one. The output after executing the script will be the ID of the new docker image.

Usage:

# Build an image using the Dockerfile at current location

# Example: docker build -t [name] .

$ docker build -t my_mongodb .    
---


Dockerfile Example: Creating an Image to Install MongoDB
+++

In this final section for Dockerfiles, we will create a Dockerfile document and populate it step-by-step with the end result of having a Dockerfile, which can be used to create a docker image to run MongoDB containers.

Creating the Empty Dockerfile
---

Using the nano text editor, let's start editing our Dockerfile.

nano Dockerfile


Defining Our File and Its Purpose
---

Albeit optional, it is always a good practice to let yourself and everybody figure out (when necessary) what this file is and what it is intended to do. For this, we will begin our Dockerfile with fancy comments (i#) to describe it - and have it like cool kids.


        ############################################################
        # Dockerfile to build MongoDB container images
        # Based on Ubuntu
        ############################################################


Setting The Base Image to Use
---

        # Set the base image to Ubuntu
        FROM ubuntu

Defining The Maintainer (Author)
---

        # File Author / Maintainer
        MAINTAINER Example McAuthor


Updating The Application Repository List
---

Note: This step is not necessary, given that we are not using the repository right afterwards. However, it can be considered good practice.


        # Update the repository sources list
        RUN apt-get update


Setting Arguments and Commands for Downloading MongoDB
---


        ################## BEGIN INSTALLATION ######################
        # Install MongoDB Following the Instructions at MongoDB Docs
        # Ref: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/

        # Add the package verification key
        RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10

        # Add MongoDB to the repository sources list

        RUN echo 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' | tee /etc/apt/sources.list.d/mongodb.list

        # Update the repository sources list once more

        RUN apt-get update

        # Install MongoDB package (.deb)
        RUN apt-get install -y mongodb-10gen

        # Create the default data directory
        RUN mkdir -p /data/db

        ##################### INSTALLATION END #####################

MY NOTE: in the comments section it was said it's better practice to avoid using separate RUN directives where possible as each RUN command adds an additional layer to the image, creating unnecessary bloat. Later below in this text I have added a modified Dockerfile which follows this advice.

QUOTE from comments:
February 17, 2015

One thing to note, each time you use the RUN command, it makes a layer in your image which may bloat your total image tree (if you run docker images --tree in the terminal to view the tree structure).
MY NOTE (there is no --tree option to docker images, so presumably the below command does the same job): 
$ docker images --all

If you don't want all those layers, use a single RUN command. A great example of this is actually the Dockerfile for the ubuntu image.
https://github.com/tianon/docker-brew-ubuntu-core/blob/a9da4b3cd8977c2aacafe5d9d0056cbb360f2d1c/vivid/Dockerfile

June 29, 2016

This should be mentioned in the section on the RUN command, since inadvertently adding layers is not best practice or a good habit for a beginner to build. Nice info.



Setting The Default Port For MongoDB
---

        # Expose the default port
        EXPOSE 27017

        # Default port to execute the entrypoint (MongoDB)
        CMD ["--port 27017"]

        # Set default container command
        ENTRYPOINT usr/bin/mongod

The resulting Dockerfile 
---

https://github.com/triogh/ubuntu_server/blob/master/docs/example_docker/mongodb/Dockerfile

Has some of my additional modifications related to RUN directives, and also some updates necessary for the Dockerfile to work in the present time (2016), since the tutorial was created in 2013. 



        ###################################################
        # Dockerfile to build MongoDB container images
        # Based on Ubuntu
        ###################################################

        # Set the base image to Ubuntu
        FROM ubuntu

        # File Author / Maintainer
        MAINTAINER Example McAuthor

        # Update the repository sources list
        RUN apt-get update

        ##################### BEGIN INSTALLATION ####################

        # Install MongoDB Following the Instructions at MongoDB Docs
        # Ref: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/

        # Add the package verification key
        RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927

        # Add MongoDB to the repository sources list
        RUN echo "deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse" | tee /etc/apt/sources.list.d/mongodb-org-3.2.list

        # Update the repository sources list once more
        RUN apt-get update

        # Install MongoDB package (.deb)
        RUN apt-get install -y mongodb-org

        # Create the default data directory
        RUN mkdir -p /data/db

        # ubuntu 16.04 specific
        # https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/

        RUN echo "[Unit]" | tee -a /lib/systemd/system/mongod.service \
            && echo "Description=High-performance, schema-free document-oriented database" | tee -a /lib/systemd/system/mongod.service \
            && echo "After=network.target" | tee -a /lib/systemd/system/mongod.service \
            && echo "Documentation=https://docs.mongodb.org/manual" | tee -a /lib/systemd/system/mongod.service \
            && echo "" | tee -a /lib/systemd/system/mongod.service \
            && echo "[Service]" | tee -a /lib/systemd/system/mongod.service \
            && echo "User=mongodb" | tee -a /lib/systemd/system/mongod.service \
            && echo "Group=mongodb" | tee -a /lib/systemd/system/mongod.service \
            && echo "ExecStart=/usr/bin/mongod --quiet --config /etc/mongod.conf" | tee -a /lib/systemd/system/mongod.service \
            && echo "" | tee -a /lib/systemd/system/mongod.service \
            && echo "[Install]" | tee -a /lib/systemd/system/mongod.service \
            && echo "WantedBy=multi-user.target" | tee -a /lib/systemd/system/mongod.service

        ##################### END INSTALLATION ####################

        # Expose the default port
        EXPOSE 27017

        # Default port to execute the entrypoint (MongoDB)

        CMD ["--port 27017"]

        # Set default container command
        ENTRYPOINT /usr/bin/mongod


Building Our First Image
+++

Using the explanations from before, we are ready to create our first MongoDB image with docker!

$ docker build -t my_mongodb .
---

Note: The -t [name] flag here is used to tag the image. To learn more about what else you can do during build, run sudo docker build --help.


Running A MongoDB Instance
+++

Using the image we have build, we can now proceed to the final step: creating a container running a MongoDB instance inside, using a name of our choice (if desired with -name [name]).

$ docker run --name my_first_mdb_instance -i -t my_mongodb
---

Note: If a name is not set, we will need to deal with complex, alphanumeric IDs which can be obtained by listing all the containers using sudo docker ps -l.

Note: To detach yourself from the container, use the escape sequence CTRL+P followed by CTRL+Q.


Title: docker-explained-how-to-containerize-and-use-nginx-as-a-proxy
===
Source: https://www.digitalocean.com/community/tutorials/docker-explained-how-to-containerize-and-use-nginx-as-a-proxy

Added: Sat Nov  5 18:29:31 CET 2016
Created: PostedDecember 16, 2013

Introduction
+++
In this DigitalOcean article, we will learn about quickly setting up docker, creating a docker container from a base image, and building it to run Nginx layer by layer. Afterwards, following our steps from the beginning, we will create a Dockerfile to automate this entire process. In the end, using this Nginx docker image, you will be able to create self-contained sandboxes running Nginx, which can be used to serve your "dockerised" applications.

Docker in Brief
+++
The docker project offers higher-level tools, working together, which are built on top of some Linux kernel features. The goal is to help developers and system administrators port applications - with all of their dependencies conjointly - and get them running across systems and machines - headache free.

Docker achieves this by creating safe, LXC (i.e. Linux Containers) based environments for applications called “docker containers”. These containers are created using docker images, which can be built either by executing commands manually or automatically through Dockerfiles.


Nginx in Brief
+++
Nginx is a very high performant web server / (reverse)-proxy). It has reached its popularity due to being light weight, relatively easy to work with, and easy to extend (with add-ons / plug-ins). Thanks to its architecture, it is capable of handling a lot of requests (virtually unlimited), which - depending on your application or website load - could be really hard to tackle using older alternatives. It can be considered the tool to choose for serving static files such as images, scripts or style-sheets.

Building a Docker Container With Nginx Installed
+++

Note: Although after following this section we will have a running docker container with Nginx installed, it is definitely not the recommended method due to its complexity. However, it is here to offer you a chance to learn how to work with a live container and get familiarized with the commands we will need to define later to automate the process. To create a docker image with Nginx installed in a much better way, see the next section: Creating a Dockerfile to Automatically Build Nginx Image.

Creating a Base Docker Container From Ubuntu
+++

Using docker's RUN command, we will begin with creating a new container based on the Ubuntu image. We are going to attach a terminal to it using the “-t” flag.

$ docker run -i -t -p 80:80 ubuntu /bin/bash
---

Note: After executing this command, docker might need to pull the Ubuntu image before creating a new container for you.

Remember: You will be attached to the container you create. In order to detach yourself and go back to your main terminal access point, run the escape sequence: CTRL+P followed by CTRL+Q. Being attached to a docker container is like being connected to a new droplet from inside another.

To attach yourself back to this container:

    - List all running containers using sudo docker ps
    - Find its ID
    - Use "$ docker attach [id]" to attach back to its terminal

Important: Please do not forget that since we are in a container, all the following commands will be executed there, without affecting the host.

Preparing the Base Container for Nginx Installation
+++
Update the list with the newly added source.

apt-get update


Before we proceed to install Nginx, there are some tools we should have installed such as nano - just in case.

apt-get install -y nano wget dialog net-tools    



Installing Nginx
+++
Thanks to having it available in the repository, we can simply use apt-get to download and install nginx.

apt-get install -y nginx


Configuring Nginx
+++

Using the text editor nano, which we have installed in the previous step, let's create a sample Nginx configuration to proxy connections to application servers.

# Delete the default configuration
rm -v /etc/nginx/nginx.conf

# Create a blank one using nano text editor
nano /etc/nginx/nginx.conf

First, on top of the file, a line must be added to not to have Nginx spawn its processes and then quit.

The reason we cannot allow this to happen is because docker depends on a single process to run (which can even be a process manager nonetheless) and when that process stops (i.e. quitting after spawning workers), the container stops.

Start with the following as the first line of the nginx.conf:

daemon off;
---

We will use a simple sample configuration to have Nginx run as a reverse proxy. Copy-and-paste the following after the daemon off; instruction.



        worker_processes 1;
        events { worker_connections 1024; }

        http {

            sendfile on;

            gzip              on;
            gzip_http_version 1.0;
            gzip_proxied      any;
            gzip_min_length   500;
            gzip_disable      "MSIE [1-6]\.";
            gzip_types        text/plain text/xml text/css
                              text/comma-separated-values
                              text/javascript
                              application/x-javascript
                              application/atom+xml;

            # List of application servers
            upstream app_servers {

                server 127.0.0.1:8080;

            }

            # Configuration for the server
            server {

                # Running port
                listen 80;

                # Proxying the connections connections
                location / {

                    proxy_pass         http://app_servers;
                    proxy_redirect     off;
                    proxy_set_header   Host $host;
                    proxy_set_header   X-Real-IP $remote_addr;
                    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header   X-Forwarded-Host $server_name;

                }
            }
        }




Save and exit pressing CTRL+X and confirming with Y.  
To run Nginx, you can execute the following:

service nginx start

And that's it! We now have Nginx running in a docker container, accessible from the outside world on port 80 as we set using the -p 80:80 flag.

Remember: This Nginx file, albeit configured correctly, will not do anything since there are currently no application servers running on the server. Instead of this one, you can copy and use another example which simply works as a forward proxy for testing HTTP headers until you have your application server(s) installed and working.


Creating the Dockerfile to Automatically Build the Image
+++

As we have mentioned in the previous step, it is certainly not the recommended way to create containers this way for scalable production. The right way to do can be considered as using Dockerfiles to automate the build process in a structured way.

After having gone through the necessary commands for downloading and installing Nginx inside a container, we can use the same knowledge to compose a Dockerfile that docker can use to build an image, which then can be used to run Nginx instances easily.

Before we start working on the Dockerfile, let's quickly go over the basics.


Dockerfile Basics
+++

Dockerfiles are scripts containing commands declared successively which are to be executed in that order by docker to automatically create a new docker image. They help greatly with deployments.

These files always begin with defining an base image using the FROM command. From there on, the build process starts and each following action taken forms the final image which will be committed on the host.

Usage:

        # Build an image using the Dockerfile at current location
        # Tag the final image with [name] (e.g. *nginx*)
        # Example: sudo docker build -t [name] .
        $ docker build -t nginx_img . 

Dockerfile Commands Overview
+++

    - ADD: Copy a file from the host into the container
    - CMD: Set default commands to be executed, or passed to the ENTRYPOINT
    - ENTRYPOINT: Set the default entrypoint application inside the container
    - ENV: Set environment variable (e.g. key = value)
    - EXPOSE: Expose a port to outside
    - FROM: Set the base image to use
    - MAINTAINER: Set the author / owner data of the Dockerfile
    - RUN: Run a command and commit the ending result (container) image
    - USER: Set the user to run the containers from the image
    - VOLUME: Mount a directory from the host to the container
    - WORKDIR: Set the directory for the directives of CMD to be executed



Creating the Dockerfile
+++

To create a Dockerfile at the current location using the nano text editor, execute the following command:

		nano Dockerfile

Note: Append all the following lines one after the other to form the Dockerfile to be saved and used for building.
Defining the Fundamentals

Let's begin our Dockerfile by defining the basics (fundamentals) such as the FROM image (i.e. Ubuntu) and the MAINTAINER.


		############################################################
		# Dockerfile to build Nginx Installed Containers
		# Based on Ubuntu
		############################################################

		# Set the base image to Ubuntu
		FROM ubuntu

		# File Author / Maintainer
		MAINTAINER Maintaner Name


Installation Instructions for Nginx
+++

Following our steps from the previous section, let's form the block to have Nginx installed.


		# Install Nginx
		# Update the repository
		RUN apt-get update

		# Install necessary tools
		RUN apt-get install -y nano wget dialog net-tools

		# Download and Install Nginx
		RUN apt-get install -y nginx    


Bootstrapping
+++

After adding the instructions for installing Nginx, let's finish off with configuring Nginx and getting Dockerfile to replace the default configuration file with one we provide during build.


		# Remove the default Nginx configuration file
		RUN rm -v /etc/nginx/nginx.conf

		# Copy a configuration file from the current directory
		ADD nginx.conf /etc/nginx/

		# Append "daemon off;" to the beginning of the configuration
		RUN echo "daemon off;" >> /etc/nginx/nginx.conf

		# Expose ports
		EXPOSE 80

		# Set the default command to execute
		# when creating a new container
		CMD service nginx start


Final Dockerfile
+++

In the end, this is what the Dockerfile should look like:


		############################################################
		# Dockerfile to build Nginx Installed Containers
		# Based on Ubuntu
		############################################################

		# Set the base image to Ubuntu
		FROM ubuntu

		# File Author / Maintainer
		MAINTAINER Maintaner Name

		# Install Nginx

		# Add application repository URL to the default sources
		RUN echo "deb http://archive.ubuntu.com/ubuntu/ raring main universe" >> /etc/apt/sources.list

		# Update the repository
		RUN apt-get update

		# Install necessary tools
		RUN apt-get install -y nano wget dialog net-tools

		# Download and Install Nginx
		RUN apt-get install -y nginx  

		# Remove the default Nginx configuration file
		RUN rm -v /etc/nginx/nginx.conf

		# Copy a configuration file from the current directory
		ADD nginx.conf /etc/nginx/

		# Append "daemon off;" to the beginning of the configuration
		RUN echo "daemon off;" >> /etc/nginx/nginx.conf

		# Expose ports
		EXPOSE 80

		# Set the default command to execute
		# when creating a new container
		CMD service nginx start


MY NOTE:
Below is a Dockerfile, that builds an image with nginx installed and started.

To build an image from the docker file below, you could issue the command below.

$ docker build -t my_nginx_image .
---

To run a container with that image you could issue the command below.

$ docker run -it -p80:80 --name my_nginx_container [image]
---

To run the same container and have a bash shell.

$ docker run -it -p80:80 --name [container_name] [image] /bin/bash
---


		####################################################
		# Dockerfile to build Nginx Installed Containers
		# Based on Ubuntu
		####################################################

		# Set the base image to Ubuntu
		FROM ubuntu

		# File Author / Maintainer
		MAINTAINER User McExample

		##################### Install Nginx ####################

		# Update the repository
		# Install necessary tools
		# Install Nginx
		RUN apt-get update \
			&& apt-get install -y vim wget dialog net-tools \
			&& apt-get install -y nginx \
			&& echo "daemon off;" >> /etc/nginx/nginx.conf


		# Expose ports
		EXPOSE 80

		# Set default command to execute when creating new container
		CMD service nginx start



Using the Dockerfile to Automatically Build Nginx Containers
+++

As we first went over in the "basics" section, Dockerfiles' usage consists of calling them with “docker build” command.

Since we are instructing docker to copy a configuration (i.e. nginx.conf) from the current directory to replace the default one, we need to make sure to have it alongside this Dockerfile before starting the build process.

Note: The above explained procedure of copying in an Nginx configuration allows you great flexibility and saves a lot of time by not dealing with attaching and detaching yourself from containers to create configuration files. Now you can simply use one to directly build and run an image.


Create a sample nginx.conf using the text editor nano:



        nano nginx.conf



And replace its contents to use it as a forward proxy for testing:



		worker_processes 1;
		events { worker_connections 1024; }

		http {

			sendfile on;

			server {

				listen 80;

				location / {
					proxy_pass http://httpstat.us/;
					proxy_set_header  X-Real-IP  $remote_addr;
				}
			}
		}


MY NOTE:
The final Docker file I used succesfully.



		####################################################
		# Dockerfile to build Nginx Installed Containers
		# Based on Ubuntu
		####################################################

		# Set the base image to Ubuntu
		FROM ubuntu

		# File Author / Maintainer
		MAINTAINER User McExample

		##################### Install Nginx ####################

		# Update the repository
		# Install necessary tools
		# Install Nginx
		RUN apt-get update \
			&& apt-get install -y vim wget dialog net-tools \
			&& apt-get install -y nginx \
			&& rm -v /etc/nginx/nginx.conf

		# Copy a configuration file from the current directory
		ADD nginx.conf /etc/nginx


		# Expose ports
		EXPOSE 80

		# Set default command to execute when creating new container
		CMD service nginx start


MY NOTE:
The nginx.conf file I used, same as the one provided by Digital Ocean, except the one i succesfully used has "daemon off;" on top.



		daemon off;
		worker_processes 1;
		events { worker_connections 1024; }

		http {

			sendfile on;

			server {

				listen 80;

				location / {
					proxy_pass http://httpstat.us/;
					proxy_set_header  X-Real-IP  $remote_addr;
				}
			}
		}



This docker image will allow us to port all our progress and quickly create containers running Nginx with a single command.

To start using it, build a new container image with the following:

$docker build -t nginx_img_1 . 
---

And using that image - which we tagged as nginximg1 - we can run a new container:

$ docker run --name nginx_cont_1 -p 80:80 -i -t nginx_img_1
---

Now you can visit the IP address of your droplet, and your Nginx running docker container shall do its job, forwarding you to the HTTP status testing page.

Example:

		# Usage: Visit http://[my droplet's ip]
		http://95.85.10.236/200

		Sample Response:

		200 OK


Title: docker-explained-how-to-create-docker-containers-running-memcached
===
Source: https://www.digitalocean.com/community/tutorials/docker-explained-how-to-create-docker-containers-running-memcached

Added: Sun Nov  6 12:58:18 CET 2016
Created: PostedDecember 16, 2013


Introduction
+++

For the majority of web applications, it is extremely rare to find the CPU being the culprit for the dropped HTTP requests or choking the web server hosting them. It usually is an under-engineered setup with no caching layer involved, eating up all the resources of the backend data store (i.e. your database of choice).

Memcached - which by now should need no introduction - can increase the performance of your application deployment stack greatly without making any amendments to your available resources (enabling you to squeeze every last bit of its juices).

In this DigitalOcean article, especially keeping in mind those who host multiple web applications (e.g. multiple WordPress instances, Python Applications, etc.), we are going to create docker images to quickly start running (on-demand) Memcached containers which can be operated individually. These containers, kept and secured within their own environments, will work with the application being hosted to help them get better and faster.


Memcached in Brief
+++

Memcached is a distributed, open-source data storage engine. It was designed to store certain types of data in RAM (instead of slower rate traditional disks) for very fast retrievals by applications, cutting the amount of time it takes to process requests by reducing the number of queries performed against heavier datasets or APIs such as traditional databases (e.g. MySQL).

By introducing a smart, well-planned, and optimized caching mechanism, it becomes possible to handle a seemingly larger amount of requests and perform more procedures by applications. This is the most important use case of Memcached, as it is with any other caching application or component.

Heavily relied upon and used in production for web sites and various other applications, Memcached has become one of the go-to tools for increasing performance without -necessarily - needing to utilize further hardware (e.g. more servers or server resources).

It works by storing keys and their matching values (up to 1 MB in size) onto an associative array (i.e. hash table) which can be scaled and distributed across a large number of virtual servers.


Basic Docker Commands
+++

docker CLI Usage:

docker [option] [command] [arguments]


Commands List

Here is a summary of currently available (version 0.7.1) docker commands:


attach        - Attach to a running container
build        - Build a container from a Dockerfile
commit        - Create a new image from a container's changes
cp        - Copy files/folders from the containers filesystem to the host path
diff        - Inspect changes on a container's filesystem
events        - Get real time events from the server
export        - Stream the contents of a container as a tar archive
history        - Show the history of an image
images        - List images
import        - Create a new filesystem image from the contents of a tarball
info        - Display system-wide information
insert        - Insert a file in an image
inspect        - Return low-level information on a container
kill        - Kill a running container
load        - Load an image from a tar archive
login        - Register or Login to the docker registry server
logs        - Fetch the logs of a container
port        - Lookup the public-facing port which is NAT-ed to PRIVATE_PORT
ps        - List containers
pull        - Pull an image or a repository from the docker registry server
push        - Push an image or a repository to the docker registry server
restart        - Restart a running container
rm        - Remove one or more containers
rmi        - Remove one or more images
run        - Run a command in a new container
save        - Save an image to a tar archive
search        - Search for an image in the docker index
start        - Start a stopped container
stop        - Stop a running container
tag        - Tag an image into a repository
top        - Lookup the running processes of a container
version        - Show the docker version information



Getting Started with Creating Memcached Images
+++

Building on our knowledge gained from the previous articles in the docker series, let's dive straight into building a Dockerfile to have docker automatically build Memcached installed images (which will be used to run sandboxed Memcached instances).


Quick Recap: What Are Dockerfiles?
+++

Dockerfiles are scripts containing commands declared successively which are to be executed, in the order given, by docker to automatically create a new docker image. They help greatly with deployments.

These files always begin with the definition of a base image by using the FROM command. From there on, the build process starts and each following action taken forms the final with commits (saving the image state) on the host.

Usage:

        # Build an image using the Dockerfile at current location
        # Tag the final image with [name] (e.g. *nginx*)
        # Example: sudo docker build -t [name] .
        docker build -t memcached_img . 


Dockerfile Commands Overview
+++


ADD        - Copy a file from the host into the container
CMD        - Set default commands to be executed, or passed to the ENTRYPOINT
ENTRYPOINT        - Set the default entrypoint application inside the container
ENV        - Set environment variable (e.g. "key = value")
EXPOSE        - Expose a port to outside
FROM        - Set the base image to use
MAINTAINER        - Set the author / owner data of the Dockerfile
RUN        - Run a command and commit the ending result (container) image
USER        - Set the user to run the containers from the image
VOLUME        - Mount a directory from the host to the container
WORKDIR        - Set the directory for the directives of CMD to be executed


Creating a Dockerfile
+++

Since Dockerfiles constitute of plain-text documents, creating one translates to launching your favourite text editor and writing the commands you want docker to execute in order to build an image. After you start working on the file, continue with adding all the content below (one after the other) before saving the final result.

Note: You can find what the final Dockerfile will look like at the end of this section.

Let's create an empty Dockerfile using nano text editor:

nano Dockerfile

We need to have all instructions (commands) and directives listed successively. However, everything starts with building on a base image (set with the FROM command).

Let's define the purpose of our Dockerfile and declare the base image to use:



        ############################################################
        # Dockerfile to run Memcached Containers
        # Based on Ubuntu Image
        ############################################################

        # Set the base image to use to Ubuntu
        FROM ubuntu

        # Set the file maintainer (your name - the file's author)
        MAINTAINER Maintaner Name



After this initial block of commands and declarations, we can begin with listing the instructions for Memcached installation.


        # Update the default application repository sources list
        RUN apt-get update

        # Install Memcached
        RUN apt-get install -y memcached

Set the default port to be exposed to outside the container:


        # Port to expose (default: 11211)
        EXPOSE 11211

Set the default execution command and entrpoint (i.e. Memcached daemon):


        # Default Memcached run command arguments
        CMD ["-u", "root", "-m", "128"]

        # Set the user to run Memcached daemon
        USER daemon

        # Set the entrypoint to memcached binary
        ENTRYPOINT memcached


Final Dockerfile
+++


        ############################################################
        # Dockerfile to run Memcached Containers
        # Based on Ubuntu Image
        ############################################################

        # Set the base image to use to Ubuntu
        FROM ubuntu

        # Set the file maintainer (your name - the file's author)
        MAINTAINER Maintaner Name

        # Update the default application repository sources list
        RUN apt-get update

        # Install Memcached
        RUN apt-get install -y memcached

        # Port to expose (default: 11211)
        EXPOSE 11211

        # Default Memcached run command arguments
        CMD ["-m", "128"]

        # Set the user to run Memcached daemon
        USER daemon

        # Set the entrypoint to memcached binary
        ENTRYPOINT memcached



Using this Dockerfile, we are ready to get started with dockerised Memcached containers!


Creating the Docker Image for Memcached Containers
+++

We can now create our first Memcached image by following the usage instructions explained in the Dockerfile Basics section.

Run the following command to create an image, tagged as "memcached_img":

$ docker build -t memcached_img .
---

Note: Do not forget the trailing . for docker to find the Dockerfile.


Running dockerised Memcached Containers
+++

It is very simple to create any number of perfectly isolated and self-contained memcached instances - now - thanks to the image we have obtained in the previous section. All we have to do is to create a new container with docker run.


Creating a Memcached Installed Container
+++

To create a new container, use the following command, modifying it to suit your requirements following this example:


# Example: docker run --name [container name] -p [port to access:port exposed] -i -t [memcached image name]

$ docker run --name memcached_ins -d -p 45001:11211 memcached_img
---


Now we will have a docker container named "memcachedins", accessible from port 45001, run using our image tagged "memcachedimg", which we built previously.


Limiting the Memory for a Memcached Container
+++

In order to limit the amount of memory a docker container process can use, simply set the -m [memory amount] flag with the limit.

To run a container with memory limited to 256 MBs:

# Example: sudo docker run -name [name] -m [Memory (int)][memory unit (b, k, m or g)] -d (to run not to attach) -p (to set access and expose ports) [image ID]

$ docker run --name memcached_ins -m 256m -d -p 45001:11211 memcached_img
---


To confirm the memory limit, you can inspect the container:

# Example: docker inspect [container ID] | grep Memory

$ docker inspect memcached_ins | grep Memory
---

Note: The command above will grab the memory related information from the inspection output. To see all the relevant information regarding your container, opt for docker inspect [container ID].


Testing the Memcached Container
+++

There are various ways to try your newly created Memcached running container(s). We will use a simple Python CLI application for this. However, you can just get to production with your application using caching add-ons, frameworks, or libraries.

Make sure that your host has the necessary libraries for Python / Memcached:


		sudo apt-get update && sudo apt-get -y upgrade 
		sudo apt-get install -y python-pip
		pip install python-memcached


Let's create a simple Python script called "mc.py" using nano:

nano cache.py

Copy-and-paste the below (self-explanatory) content inside:


		# Import python-memcache and sys for arguments
		import memcache
		import sys

		# Set address to access the Memcached instance
		addr = 'localhost'

		# Get number of arguments
		# Expected format: python cache.py [memcached port] [key] [value]
		len_argv = len(sys.argv)

		# At least the port number and a key must be supplied
		if len_argv < 3:
			sys.exit("Not enough arguments.")

		# Port is supplied and a key is supplied - let's connect!
		port  = sys.argv[1]
		cache = memcache.Client(["{0}:{1}".format(addr, port)])

		# Get the key
		key   = str(sys.argv[2])

		# If a value is also supplied, set the key-value pair
		if len_argv == 4:

			value = str(sys.argv[3])    
			cache.set(key, value)

			print "Value for {0} set!".format(key)

		# If a value is not supplied, return the value for the key
		else:

			value = cache.get(key)

			print "Value for {0} is {1}.".format(key, value) 



Testing a docker memcached instance using the script above from your host:


        # Example: python cache.py [port] [key] [value]
		python cache.py 45001 my_test_key test_value

        # Return: Value for my_test_key set


        # See if the key is set:
		python cache.py 45001 my_test_key

        # Return: Value for my_test_key is test_value.

